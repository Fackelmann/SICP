#+PROPERTY: header-args    :exports both
This is an org-mode file with ~scheme~ code blocks. If you clone this repo you can execute each block inside this file with ~C-c C-c~.

Because of some mysterious reason, results don't show up in the rendered github file. You can see them by opening the raw file.

* Table of Contents :TOC:
- [[#exercise-11][Exercise 1.1]]
- [[#exercise-12][Exercise 1.2]]
- [[#exercise-13][Exercise 1.3]]
- [[#exercise-14][Exercise 1.4]]
- [[#exercise-15][Exercise 1.5]]
- [[#exercise-16][Exercise 1.6]]
- [[#exercise-17][Exercise 1.7]]
- [[#exercise-18][Exercise 1.8]]
- [[#exercise-19][Exercise 1.9]]
- [[#exercise-110][Exercise 1.10]]
- [[#exercise-111][Exercise 1.11]]
- [[#exercise-112][Exercise 1.12]]
- [[#exercixe-114][Exercixe 1.14]]
- [[#exercise-115][Exercise 1.15]]
- [[#exercise-116][Exercise 1.16]]
- [[#exercise-117][Exercise 1.17]]
- [[#exercise-118][Exercise 1.18]]
- [[#exercise-119][Exercise 1.19]]
- [[#exercise-120][Exercise 1.20]]
  - [[#normal-order][Normal order]]
  - [[#applicative-order][Applicative order]]
- [[#exercise-121][Exercise 1.21]]
- [[#exercise-122][Exercise 1.22]]
- [[#exercise-123][Exercise 1.23]]
- [[#exercise-124][Exercise 1.24]]
- [[#exercise-125][Exercise 1.25]]

* Exercise 1.1
#+BEGIN_SRC scheme
10
#+END_SRC

#+RESULTS:
: 10

Answer: 10

#+BEGIN_SRC scheme
(+ 5 3 4)
#+END_SRC

#+RESULTS:
: 12

Answer: 12

#+BEGIN_SRC scheme
(- 9 1)
#+END_SRC

#+RESULTS:
: 8

Answer: 8
#+BEGIN_SRC scheme
(/ 6 2)
#+END_SRC

#+RESULTS:
: 3

Answer: 3


#+BEGIN_SRC scheme
(+ (* 2 4) (- 4 6))
#+END_SRC

#+RESULTS:
: 6

Answer: 6

#+BEGIN_SRC scheme
(define a 3)
#+END_SRC
#+RESULTS:
: #<unspecified>

#+BEGIN_SRC scheme
(define b (+ a 1))
#+END_SRC



#+BEGIN_SRC scheme
(define a 3)
(define b (+ a 1))
(+ a 2)
#+END_SRC

#+RESULTS:
: 5

Answer: 5

#+BEGIN_SRC scheme var: a=a b=b
(define a 3)
(define b (+ a 1))
(+ a b (* a b))
#+END_SRC

#+RESULTS:
: 19
Answer: 21

#+BEGIN_SRC scheme
(define a 3)
(define b (+ a 1))
(= a b)
#+END_SRC

#+RESULTS:
: #f

#+BEGIN_SRC scheme
(define a 3)
(define b (+ a 1))
(if (and (> b a) (< b (* a b)))
              b
              a)
#+END_SRC

#+RESULTS:
: 4

Answer: 4

#+BEGIN_SRC scheme
(define a 3)
(define b (+ a 1))
(cond ((= a 4) 6)
      ((= b 4) (+ 6 7 a))
      (else 25))
#+END_SRC

#+RESULTS:
: 16

Answer: 16. Second predicate.

#+BEGIN_SRC scheme
(define a 3)
(define b (+ a 1))
(+ 2 (if (> b a) b a))
#+END_SRC

#+RESULTS:
: 6

Answer: 6. 2 + 4, since b is greater than a.

#+BEGIN_SRC scheme
(define a 3)
(define b (+ a 1))
(* (cond ((> a b) a)
         ((< a b) b)
         (else -1))
   (+ a 1))
#+END_SRC

#+RESULTS:
: 16

Answer: 16, B*(A+1). second predicate

* Exercise 1.2
Translate the following expression into prefix form.

#+BEGIN_SRC
          5 + 4 + (2 - (3 - (6 + 4/5)))
          -----------------------------
                 3(6 - 2)(2 - 7)
#+END_SRC
#+BEGIN_SRC scheme
(/ (+ 5
      4
      (- 2
         (- 3
            (+ 6
               (/ 4 5)))))
   (* 3
      (- 6 2)
      (- 7 2)))
#+END_SRC

#+RESULTS:
: 37/150

* Exercise 1.3
#+BEGIN_SRC scheme :results output
(define (sum-squares x y)
  (+ (* x x) (* y y)))

(define (>= x y)
       (not (< x y)))

(define (proc x y z)
  (cond ((and (>= x z)
              (>= y z))
        (sum-squares x y))
        ((and (>= x y)
              (>= z y))
        (sum-squares x z))
        ((and (>= y x)
              (>= z x))
        (sum-squares y z ))))
(display (proc 2 10 5))
(display "\n")
(display (proc 1 2 2))
(display "\n")
(display (proc 5 3 1))
#+END_SRC

#+RESULTS:
: 125
: 8
: 34

* Exercise 1.4
If be is positive, the if statement will evaluate to ~+~. So the procedure will evaluate to ~(+ a b)~. Conversely, if the statement is negative, it will evaluate to ~(- a b)~. The result is that the procedure will return a plus the absolute value of b.

* Exercise 1.5
We have:

#+BEGIN_SRC scheme
(define (p) (p))
(define (test x y)
  (if (= x 0)
      0
      y))
;;(test 0 (p))
#+END_SRC

#+RESULTS:
: #<unspecified>

In an interpreter that uses *applicative-order* evaluation, we'll enter an infinite loop.
The reason is that the interpreter evaluates the operator, and the *operands*. When we expand the operator there are no issues, but when we expand the operand we enter an infinite loop.

In an interpreter that uses *normal-order* evaluation, it will return ~0~. The reason is that the operands are not evaluated until needed. Since x is equal to 0 when we call the procedure, the if statement will return 0 without evaluatin the argument ~y~, which is the procedure p that was causing the infinie loop in the applicative-order case.

* Exercise 1.6
New-if will use applicative-order evaluation. This means that the operands of the proceudre will be evaluated before cond, entering a loop when it has to evaluate sqrt-iter in the second predicate.

* Exercise 1.7
#+BEGIN_SRC scheme :results output
(define (sqrt-iter guess x)
  (if (good-enough? guess x)
      guess
      (sqrt-iter (improve guess x)
                 x)))
(define (improve guess x)
  (average guess (/ x guess)))

(define (average x y)
  (/ (+ x y) 2))

(define (square x)
  (* x x))

(define (good-enough? guess x)
  (< (abs (- (square guess) x)) 0.001))

(display (square (sqrt-iter 1 1e-20)))
(display "\n")
(display (square (sqrt-iter 1 1e-3)))
(display "\n")
(display (square (sqrt-iter 1 1e-4)))
(display "\n")
(display (square (sqrt-iter 1 1e-5)))
(display "\n")
(display (square (sqrt-iter 1 1e21)))
#+END_SRC
#+RESULTS:
: 9.765625e-4
: 0.0017011851721075596
: 0.0010438358335233748
: 9.832294718753643e-4


If the square of the guess differs less than 0.001 from the number, that will be returned as a result. But if the number is less than 0.001, this means that we will end up returning results close to ~sqrt(0.001)~, as ~x~ in the difference will be much lower than ~(square guess)~.

For large numbers, we will enter an infinite loop. The reason is that due to limited precision, given a large enough number (- (square guess) x) will never been less than 0.001, we won't have so many significant digits..

#+BEGIN_SRC scheme :results output
(define (sqrt-iter guess previous-guess x)
  (if (good-enough? guess previous-guess)
      guess
      (sqrt-iter (improve guess x) guess
                 x)))

(define (improve guess x)
  (average guess (/ x guess)))

(define (average x y)
  (/ (+ x y) 2))

(define (square x)
  (* x x))

(define (good-enough? guess previous-guess)
  (< (/(abs (- guess previous-guess)) guess) 1e-6))

(define (sqrt x)
  (sqrt-iter 1.0 0 x))

(display (square (sqrt 1e-20)))
(display "\n")
(display (square (sqrt 1e-3)))
(display "\n")
(display (square (sqrt 1e-4)))
(display "\n")
(display (square (sqrt 1e-5)))
(display "\n")
(display (square (sqrt 1e21)))
#+END_SRC

#+RESULTS:
: 9.999999999999998e-21
: 0.001000000000000034
: 1.0e-4
: 1.0e-5
: 1.0000000000000033e21

* Exercise 1.8
Square root formula:
#+BEGIN_SRC
x/y^2 + 2y
----------
    3
#+END_SRC

#+BEGIN_SRC scheme :results output
  (define (curt-iter guess previous-guess x)
    (if (good-enough? guess previous-guess)
        guess
        (curt-iter (improve x guess) guess
                    x)))

  ;;(define (improve guess x)
  ;;  (average guess (/ x guess)))

  (define (improve x y)
    (/ (+ (/ x 
             (square y))
          (* 2 y))
       3))

  (define (square x)
    (* x x))

  (define (cube x)
    (* x x x))

  (define (good-enough? guess previous-guess)
    (< (/(abs (- guess previous-guess)) guess) 1e-3))

  (define (curt x)
    (curt-iter 1.0 0 x))

  (display (cube (curt 8)))
  (display "\n")
  (display (cube (curt 27)))
  (display "\n")
  (display (cube (curt 1e-4)))
  (display "\n")
  (display (cube (curt 1e-5)))
  (display "\n")
  (display (cube (curt 1e21)))
#+END_SRC

#+RESULTS:
: 8.000000000144743
: 27.000014608735402
: 1.0000000152937715e-4
: 1.0000000035166185e-5
: 1.00000023543326e21
* Exercise 1.9

#+NAME procedure A
#+BEGIN_SRC scheme
          (define (+ a b)
            (if (= a 0)
                b
                (inc (+ (dec a) b))))
#+END_SRC

#+BEGIN_SRC
(+ 4 5)
(inc (+ 3 5))
(inc (inc (+ 2 5)))
(inc (inc (inc (+ 1 5))))
(inc (inc (inc (inc (+ 0 5)))))
(inc (inc (inc (inc 5))))
(inc (inc (inc 6)))
(inc (inc 7))
(inc 8)
9
#+END_SRC

It's a linear recursive process.

#+NAME procedure B
#+BEGIN_SRC scheme
          (define (+ a b)
            (if (= a 0)
                b
                (+ (dec a) (inc b))))
#+END_SRC

#+BEGIN_SRC
(+ 4 5)
(+ 3 6)
(+ 2 7)
(+ 1 8)
(+ 0 9)
9
#+END_SRC

It's a linear iterative process
* Exercise 1.10
#+BEGIN_SRC scheme
          (define (A x y)
            (cond ((= y 0) 0)
                  ((= x 0) (* 2 y))
                  ((= y 1) 2)
                  (else (A (- x 1)
                           (A x (- y 1))))))
#+END_SRC

#+BEGIN_SRC
(A 1 10)
(A 0 (A 1 9))
(A 0 (A 0 (A 1 8)))
...
(A 0 ... (A 0 1))
#+END_SRC

This will result in 2^10=1024

#+BEGIN_SRC
(A 2 4)
(A 1 (A 2 3))
(A 1 (A 1 (A 1 2)))
#+END_SRC

We know that ~(A 1 2) = 2^2~
then this results in
2^2^2

~(define (f n) (A 0 n))~
~(f n)~ computes 2*n

~(define (g n) (A 1 n))~
~(g n)~ computes 2^n

~(define (h n) (A 2 n))~
~(h n)~ computes 2^2........^2 (n-1 times)
* Exercise 1.11
#+BEGIN_SRC scheme
(define (f n)
  (if (< n 3)
      n
      (+ (f (- n 1))
         (* 2 (f (- n 2)))
         (* 3 (f (- n 3))))))
(f 35)
#+END_SRC

#+RESULTS:
: 4630608915694

#+BEGIN_SRC scheme
    (define (f n)
      (if (< n 3)
          n
          (f-iter 2 1 0 (- n 2))))

    (define (f-iter n1 n2 n3 count)
      (if (= count 0)
          n1
          (f-iter (+ n1 (* n2 2) (* n3 3)) 
                  n1
                  n2
                  (- count 1))))
  (f 35)
#+END_SRC

#+RESULTS:
: 4630608915694

The linear iterative process is much faster.
* Exercise 1.12
Row and column are 0-indexed.

#+BEGIN_SRC scheme :results output
  (define (pascal-iter row column)
    (cond ((= row column)
           1)
          ((= column 0)
           1)
          (else (+ (pascal-iter (- row 1) (- column 1))
                   (pascal-iter (- row 1) column)))))

  (display "Testing some known values\n")
  (display (pascal-iter 3 1))
  (display "\n")
  (display (pascal-iter 4 2))
  (display "\n")
  (display (pascal-iter 5 3))
  (display "\n")
  (display (pascal-iter 10 5))
#+END_SRC

#+RESULTS:
: Testing some known values
: 3
: 6
: 10
: 252

TODO. This process is tree-recursive. Can we make it linear iterative?
* Exercixe 1.14

Let's plot the time it takes it to execute the recursive algorithm versus a range of amounts. This will give us a proxy for the order of growth of the steps:

#+BEGIN_SRC python :results file
  import matplotlib.pyplot as plt
  import time
  COINS = [1, 5, 10, 25, 50]
  def count_change(amount):
      def count_change_iter(amount, coin_idx):
          if amount == 0:
              return 1
          elif amount < 0 or coin_idx < 0:
              return 0
          else:
              return count_change_iter(amount, coin_idx-1) +\
                  count_change_iter(amount - COINS[coin_idx], coin_idx)

      return count_change_iter(amount, 4)

  print(count_change(100))

  elapsed_time = []
  for i in range(300):
      start_time = time.time()
      count_change(i)
      end_time = time.time()
      elapsed_time.append(end_time-start_time)

  fig, ax=plt.subplots()

  plt.plot(elapsed_time)
  ax.set_xlabel("Amount")
  ax.set_ylabel("Time (s)")
  ax.grid(True)
  plt.savefig("coin_change_complexity.png")
  return "coin_change_complexity.png"

#+END_SRC

#+RESULTS:
[[file:coin_change_complexity.png]]


It looks like exponential growth.

(It seems that github doesn't support embedding images in org mode documents. If it still doesn't work, just open the file ~coin_change_complexity.png~ under this same directory.)



Analytically (kind of) we can consider the case where we have (cc amount 1). In this case we will have 2 branches per step, with ~amount~ steps. This is:
Space: ~O(2n)=O(n)~
Steps: ~O(n)~

Now, what happens with ~(cc amount 2)~? It will branch in 2 different branches:
- One will be ~(cc amount 1)~, with the complexity previously mentioned.
- The other one will be ~(cc (- amount kind-of-coin (2)) 2)~. Which will keep branching the same way until amount is 0.

So we will have ~n * O(n) = O(n^2)~
Since we have 5 types of coins, the final complexity for space and steps will be ~O(n^5)~.

DISCLAIMER: This is not a full proof; more of an inspiration for a proof. I also originally saw this approach in someone else's solution, but I've lost track of it. Sorry! I will add the reference here if I find it again.
* Exercise 1.15
a. It's evaluated 5 times

b. In order to finish the recursion we have:
#+BEGIN_SRC
0.1 * 3^x > a
#+END_SRC

It follows that:
#+BEGIN_SRC
3^x > a/0.1
x > log_3 a/0.1
x = ceil(log_3 a/0.1)
#+END_SRC

Therefore, the order of growth is ~O(log n)~
* Exercise 1.16

Write linear iterative process for fast exponenciation.

#+BEGIN_SRC
b^n = (b^2)^(n/2) if n is even
b^n = b*b^(n-q) if n is odd
#+END_SRC

We will keep an acumulator, a, that will be multiplied by b every time that n is odd in the recursive prodecure.

#+BEGIN_SRC scheme :results output
  (define (expt b n)
    (fast-exp b n 1))

  (define (fast-exp b n a)
    (cond ((= n 0)
           a)
          ((even? n)
           (fast-exp (square b) (/ n 2) a))
          (else
           (fast-exp b (- n 1) (* a b)))))

  (define (even? n)
    (= (remainder n 2) 0))

  (define (square x)
    (* x x))
(display (expt 3 5))
(display "\n")
(display (expt 5 7))

#+END_SRC

#+RESULTS:
: 243
: 78125
* Exercise 1.17
#+BEGIN_SRC scheme :results output
  (define (mult a b)
    (cond ((= b 1)
           a)
          ((even? b)
           (mult (double a) (halve b)))
          (else
           (+ a (mult a (- b 1))))))


  (define (even? n)
    (= (remainder n 2) 0))

  (define (double a)
    (+ a a))

  (define (halve a)
    (/ a 2))

(display (mult 4 7))
(display "\n")
(display (mult 5 15))
#+END_SRC

#+RESULTS:
: 28
: 75

* Exercise 1.18

We can also make it a linear iterative process, similar to what we did with fast exponentiation.

#+BEGIN_SRC scheme :results output
  (define (mult a b)
    (mult-iter a b 0))

  (define (mult-iter a b acc)
    (cond ((= b 0)
           acc)
          ((even? b)
           (mult-iter (double a) (halve b) acc))
          (else
           (mult-iter a (- b 1) (+ acc a)))))


  (define (even? n)
    (= (remainder n 2) 0))

  (define (double a)
    (+ a a))

  (define (halve a)
    (/ a 2))

  (display (mult 4 7))
  (display "\n")
  (display (mult 5 15))
#+END_SRC

#+RESULTS:
: 28
: 75

* Exercise 1.19

#+BEGIN_SRC
a <- bq + aq + ap
b <- bp + aq

a' <- (bp +aq)q + (bq + aq + ap)q + (bq + aq + ap)p
    = bpq + aq^2 + bq^2 + aq^2 + apq + bpq + apq + ap^2
    = b(2pq + q^2) + a(2pq + q^2) + a(p^2 + q^2)
b' <- (bp + aq)p + (bq + aq + ap)q
    = bp^2 + apq + bq^2 + aq^2 + apq
    = b(p^2 + q^2) + a(2pq + q^2)
#+END_SRC

We see that:
#+BEGIN_SRC
p' = p^2 + q^2
q' = 2pq + q^2
#+END_SRC

#+BEGIN_SRC scheme
  (define (fib n)
    (fib-iter 1 0 0 1 n))

  (define (fib-iter a b p q count)
    (cond ((= count 0) b)
          ((even? count)
           (fib-iter a
                     b
                     (+ (square p) (square q))
                     (+ (* 2 p q) (square q))
                     (/ count 2)))
          (else (fib-iter (+ (* b q) (* a q) (* a p))
                          (+ (* b p) (* a q))
                          p
                          q
                          (- count 1)))))

  (define (square x)
    (* x x))

  (fib 7)
#+END_SRC

#+RESULTS:
: 13

* Exercise 1.20

#+BEGIN_SRC scheme
  (define (gcd a b)
    (if (= b 0)
        a
        (gcd b (remainder a b))))
#+END_SRC

~(gcd 206 40)~?
** Normal order
#+BEGIN_SRC
(gcd 206 40)
(if (= 40 0) 206 (gcd 40 (remainder 206 40))
(if (= (remainder 206 40)...
(if (= 6 0)...
(gcd (remainder 206 40) (remainder 40 (remainder 206 40)))
(if (= (remainder 40 (remainder 206 40))) 0...
(if (= 4 0)...
(gcd (remainder 40 (remainder 206 40)) (remainder (remainder 206 40) (remainder 40 (remainder 206 40))))
(if (= (remainder (remainder 206 40) (remainder 40 (remainder 206 40))) 0)..
(if (= (remainder 6 2) 0)..
(gcd (remainder (remainder 206 40) (remainder 40 (remainder 206 40))) (remainder (remainder 40 (remainder 206 40)) (remainder (remainder 206 40) (remainder 40 (remainder 206 40)))))
(if (= (remainder (remainder 40 (remainder 206 40)) (remainder (remainder 206 40) (remainder 40 (remainder 206 40)))) 0)...
(if (= (remainder 4 2) 0...
(remainder (remainder 206 40) (remainder 40 (remainder 206 40)))
(remainder 6 4)
2

#+END_SRC

14 remainders operations in if, + 4 remainder final operation = 18

** Applicative order
#+BEGIN_SRC
(gcd 206 40)
(if (= 40 0)...
(gcd 40 (remainder 206 40))
(gcd 40 6)
(if (= 6 0)...
(gcd 6 (remainder 40 6))
(gcd 6 4)
(if (= 4 0)..
(gcd 4 (remainder 6 4))
(gcd 4 2)
(if (= 2 0)...
(gcd 2 (remainder 4 2))
(gcd 2 0)
(if (= 0 0) 2..)
2
#+END_SRC
4 remainder operations

* Exercise 1.21
#+BEGIN_SRC scheme :results output
  (define (smallest-divisor n)
    (find-divisors n 2))

  (define (find-divisors n d)
    (cond ((> (square d) n)
           n)
          ((divides? d n)
           d)
          (else
           (find-divisors n (+ d 1)))))

  (define (square a)
    (* a a))

  (define (divides? d a)
    (= (remainder a d) 0))

  (display (smallest-divisor 199))
  (display "\n")
  (display (smallest-divisor 1999))
  (display "\n")
  (display (smallest-divisor 19999))
  (display "\n")
#+END_SRC 

#+RESULTS:
: 199
: 1999
: 7

* Exercise 1.22

#+BEGIN_SRC scheme :results output
  (define (smallest-divisor n)
    (find-divisor n 2))

  (define (find-divisor n test-divisor)
    (cond ((> (square test-divisor) n) n)
          ((divides? test-divisor n) test-divisor)
          (else (find-divisor n (+ test-divisor 1)))))

  (define (divides? a b)
    (= (remainder b a) 0))

  (define (prime? n)
    (= n (smallest-divisor n)))

  (define (timed-prime-test n)
    (start-prime-test n (runtime)))

  (define (start-prime-test n start-time)
    (if (prime? n)
        (report-prime (- (runtime) start-time) n )))

  (define (report-prime elapsed-time n)
    (display "\n *** \n")
    (display n)
    (display "\n")
    (display elapsed-time))
    (display "\n")

  (define (find-prime-numbers-from n max)
    (define (loop n max)
      (cond ((< n max)
             (timed-prime-test n) (loop (+ n 1) max))))
    (loop n max))

  (find-prime-numbers-from 1e3 1e4)
#+END_SRC

#+RESULTS:
: ice-9/boot-9.scm:1669:16: In procedure raise-exception:
: Unbound variable: runtime
: 
: Entering a new prompt.  Type `,bt' for a backtrace or `,q' to continue.
: scheme@(guile-user) [1]> 

For example:
#+BEGIN_SRC
100000007.
9.999999999999787e-3
#+END_SRC

and

#+BEGIN_SRC
1000000007.
.06000000000000005
#+END_SRC

We see that a factor of 10 increases the runtime by ~3, which is, approximately, sqrt(10)

* Exercise 1.23

#+BEGIN_SRC scheme :results output
  (define (smallest-divisor n)
    (find-divisor n 2))

  (define (next test-divisor)
     (if (= test-divisor 2)
         3
         (+ test-divisor 2)))

  (define (find-divisor n test-divisor)
    (cond ((> (square test-divisor) n) n)
          ((divides? test-divisor n) test-divisor)
          (else (find-divisor n (next test-divisor)))))

  (define (divides? a b)
    (= (remainder b a) 0))

  (define (prime? n)
    (= n (smallest-divisor n)))

  (define (timed-prime-test n)
    (start-prime-test n (runtime)))

  (define (start-prime-test n start-time)
    (if (prime? n)
        (report-prime (- (runtime) start-time) n )))

  (define (report-prime elapsed-time n)
    (display "\n *** \n")
    (display n)
    (display "\n")
    (display elapsed-time))
    (display "\n")

  (define (find-prime-numbers-from n max)
    (define (loop n max)
      (cond ((< n max)
             (timed-prime-test n) (loop (+ n 1) max))))
    (loop n max))

  (find-prime-numbers-from 1e9 1e10)
#+END_SRC

We see:
#+BEGIN_SRC
1000000007.
.03000000000000025
#+END_SRC

Time is exactly halved in this case.
* Exercise 1.24

#+BEGIN_SRC scheme :results output

  (define (even? num)
    (= (remainder num 2) 0))

  (define (expmod base exp m)
    (cond ((= exp 0) 1)
          ((even? exp)
           (remainder (square (expmod base (/ exp 2) m))
                      m))
          (else
           (remainder (* base (expmod base (- exp 1) m))
                      m))))

  (define (fermat-test n)
    (define (try-it a)
      (= (expmod a n n) a))
    (try-it (+ 1 (random (- n 1)))))

  (define (fast-prime? n times)
    (cond ((= times 0) true)
          ((fermat-test n) (fast-prime? n (- times 1)))
          (else false)))

  (define (prime? n)
    (fast-prime? n 20))

  (define (timed-prime-test n)
    (start-prime-test n (runtime)))

  (define (start-prime-test n start-time)
    (if (prime? n)
        (report-prime (- (runtime) start-time) n )))

  (define (report-prime elapsed-time n)
    (display "\n *** \n")
    (display n)
    (display "\n")
    (display elapsed-time)
    (display "\n"))

  (define (find-prime-numbers-from n max)
    (define (loop n max)
      (cond ((< n max)
             (timed-prime-test n) (loop (+ n 1) max))))
    (loop n max))

  (find-prime-numbers-from 1e9 1e10)
#+END_SRC


And 
#+BEGIN_SRC
(timed-prime-test 1000000007)

 *** 
1000000007
0.
#+END_SRC

It reports it as a prime and the runtime is virtually 0.

* Exercise 1.25
Let's start by pointing out an important property of modular arithmetic, which ~expmod~ is based on (it took me a while to understand how ~expmod~ worked, but this should make it clear):

#+BEGIN_SRC
(A * B) mod C = (A mod C * B mod C) mod C
#+END_SRC

When using this property to implement expmod, we end up having remainder operations where the divided < divisor, which is computationally fast to do, O(1) per remainder operation.

In contrast we have Alyssa's procedure. This procedure will compute the exponential in logarithmic time, no issue there. But then we need to calculate the reminder of a *very* large number. This is computationally expensive. This bound seems to be O(n log q) ([[https://cs.stackexchange.com/questions/12931/complexity-of-taking-mod][StackExchange]]), so we are losing all the gains we gained with the ~fast-exp~ procedure, and ending up with a slower algorithm.

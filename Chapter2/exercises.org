#+PROPERTY: header-args    :exports both
This is an org-mode file with ~scheme~ code blocks. If you clone this repo you can execute each block inside this file with ~C-c C-c~.

Because of some mysterious reason, results don't show up in the rendered github file. You can see them by opening the raw file.

* Table of Contents :TOC:
- [[#common][Common]]
- [[#exercise-21][Exercise 2.1]]
- [[#exercise-22][Exercise 2.2]]
- [[#exercise-23][Exercise 2.3]]
- [[#exercise-24][Exercise 2.4]]
- [[#exercise-25][Exercise 2.5]]
- [[#exercise-26][Exercise 2.6]]
- [[#exercise-27][Exercise 2.7]]
- [[#exercise-28][Exercise 2.8]]
- [[#exercise-29][Exercise 2.9]]
- [[#exercise-210][Exercise 2.10]]
- [[#exercise-211][Exercise 2.11]]
- [[#exercise-212][Exercise 2.12]]
- [[#exercise-217][Exercise 2.17]]
- [[#exercise-218][Exercise 2.18]]
- [[#exercise-219][Exercise 2.19]]
- [[#exercise-220][Exercise 2.20]]

* Common

Defining commong functions here, so we don't need to repeat them over all the code blocks. 
#+NAME: common_block
#+BEGIN_SRC scheme
  (define (square x)
    (* x x))

  (define (gcd a b)
    (if (= b 0)
        a
        (gcd b (remainder a b))))

  (define (power x n)
    (if (= n 0)
        1
        (* x (power x (- n 1)))))
#+END_SRC


* Exercise 2.1
#+BEGIN_SRC scheme :noweb yes :results output
  <<common_block>>
  (define (numer x) (car x))

  (define (denom x) (cdr x))

  (define (print-rat x)
    (display "\n")
    (display (numer x))
    (display "/")
    (display (denom x)))

  (define (make-rat n d)
    (define (is-positive? n d)
      (cond ((and (> n 0) (< d 0))
             -1)
            ((and (< n 0) (> d 0))
             -1)
            (else
             1)))
    (let ((g (gcd n d))
          (sign (is-positive? n d)))
      (cons (* sign (/ n g)) (* sign (/ d g)))))

  (print-rat (make-rat 3 -6))
  (print-rat (make-rat -3 6))
  (print-rat (make-rat -3 -6))
  (print-rat (make-rat 3 6))

#+END_SRC

#+RESULTS:
: 
: -1/2
: -1/2
: 1/2
: 1/2

* Exercise 2.2

#+NAME: ex_2.2
#+BEGIN_SRC scheme :results output
  (define (make-segment start end)
    (cons start end))

  (define (start-segment segment)
    (car segment))

  (define (end-segment segment)
    (cdr segment))

  (define (make-point x y)
    (cons x y))

  (define (x-point point)
    (car point))

  (define (y-point point)
    (cdr point))

  (define (print-point p)
    (display "\n")
    (display "(")
    (display (x-point p))
    (display ",")
    (display (y-point p))
    (display ")"))

  (define (midpoint-segment segment)
    (let ((start (start-segment segment))
          (end (end-segment segment)))
      (let ((midx (/ (+ (x-point start)
                        (x-point end))
                     2))
            (midy (/ (+ (y-point start)
                        (y-point end))
                     2)))
        (make-point midx midy))))

  (define my-segment (make-segment (make-point 1 1)
                                   (make-point 2 2)))

  (define midpoint (midpoint-segment my-segment))

;;  (print-point midpoint)
#+END_SRC

#+RESULTS:
: 
: (3/2,3/2)

* Exercise 2.3

#+BEGIN_SRC scheme :noweb yes :results output
  <<ex_2.2>>
  ;; Implement rectangles with sides parallel to the axis for now
  ;; Generalizing it adds complexity without addin much value (IMO) to this exercise
  (define (rectangle lower_left upper_right)
    (cons lower_left upper_right))

  (define (rect-ll rectangle)
    (car rectangle))

  (define (rect-ur rectangle)
    (cdr rectangle))

  (define (rect-perimeter rectangle)
    (* (+ (- (x-point (rect-ur rectangle))
             (x-point (rect-ll rectangle)))
          (- (y-point (rect-ur rectangle))
             (y-point (rect-ll rectangle))))
       2))

  (define (rect-area rectangle)
    (* (- (x-point (rect-ur rectangle))
          (x-point (rect-ll rectangle)))
       (- (y-point (rect-ur rectangle))
          (y-point (rect-ll rectangle)))))

  (define my-rectangle (rectangle (make-point 1 0)
                                  (make-point 10 2)))

  (display "\n")
  (display (rect-perimeter my-rectangle))
  (display "\n")
  (display (rect-area my-rectangle))
#+END_SRC

#+RESULTS:
: 
: 22
: 18

* Exercise 2.4
Check that it works as expected:
#+BEGIN_SRC scheme
(car (cons 3 2))
(car (lambda (m) (m 3 2)))
((lambda (p q) p) 3 2)
3
#+END_SRC

And ~cdr~ implementation:
#+BEGIN_SRC scheme
  (define (cdr z)
    (z (lambda (p q) q)))
#+END_SRC

* Exercise 2.5

#+BEGIN_SRC scheme :noweb yes :results output
  <<common_block>>
  (define (cons a b)
    (* (power 2 a)
       (power 3 b)))

  (define (max-exponent n a)
    (if (= 0 (remainder n a))
        (+ 1 (max-exponent (/ n a)  a))
        0))

  (define (car z)
    (max-exponent z 2))

  (define (cdr z)
    (max-exponent z 3))

  ;; Test
  ;; It seems that Guile doesn't suppor assert
  ;; strange
  ;; (let ((list (cons 5 7)))
  ;;   (assert (= (car list) 5))
  ;;   (assert (= (cdr list) 7)))

  ;; Test

  (let ((list (cons 5 7)))
    (display "\n")
    (display (= (car list) 5))
    (display "\n")
    (display (= (cdr list) 7)))

  (let ((list (cons 127 1)))
    (display "\n")
    (display (= (car list) 127))
    (display "\n")
    (display (= (cdr list) 1)))

  (let ((list (cons 21 32)))
    (display "\n")
    (display (= (car list) 21))
    (display "\n")
    (display (= (cdr list) 32)))
#+END_SRC

#+RESULTS:
: 
: #t
: #t
: #t
: #t
: #t
: #t

* Exercise 2.6

Let's start by evaluating ~(add-1 zero)~
#+BEGIN_SRC scheme
(add-1 zero)
(lambda (f) (lambda (x) (f ((zero f) x))))
#+END_SRC

And evaluating ~(zero f)~

#+BEGIN_SRC scheme
(zero f)
(lambda (f) (lambda (x) x))
(lambda (x) x)
#+END_SRC

Substituting:

#+BEGIN_SRC scheme
(lambda (f) (lambda (x) (f x)))
#+END_SRC

So one is:
#+BEGIN_SRC scheme
(define one (lambda (f) (lambda (x) (f x))))
#+END_SRC

Similarly if we evaluate ~(add-1 1)~, the number two will be:

#+BEGIN_SRC scheme
(define two (lambda (f) (lambda (x) (f (f x)))))
#+END_SRC

We can see that a number N is defined by a lambda expression in which a lambda function is applied N times to another lambda expression.

* Exercise 2.7
#+NAME: ex_2.7
#+BEGIN_SRC scheme
  (define (make-interval a b)
    (cons a b))

  (define (upper-bound interval)
    (cdr interval))

  (define (lower-bound interval)
    (car interval))

  (define (add-interval x y)
    (make-interval (+ (lower-bound x) (lower-bound y))
                   (+ (upper-bound x) (upper-bound y))))

  (define (mul-interval x y)
    (let ((p1 (* (lower-bound x) (lower-bound y)))
          (p2 (* (lower-bound x) (upper-bound y)))
          (p3 (* (upper-bound x) (lower-bound y)))
          (p4 (* (upper-bound x) (upper-bound y))))
      (make-interval (min p1 p2 p3 p4)
                     (max p1 p2 p3 p4))))

  (define (div-interval x y)
    (mul-interval x
                  (make-interval (/ 1.0 (upper-bound y))
                                 (/ 1.0 (lower-bound y)))))
#+END_SRC

#+RESULTS: ex_2.7
: #<unspecified>

* Exercise 2.8

#+BEGIN_SRC scheme :noweb yes :results output
  <<ex_2.7>>
  (define (sub-interval x y)
    (make-interval (- (lower-bound x) (upper-bound y))
                   (- (upper-bound x) (lower-bound y))))

  (display (sub-interval (make-interval 3 4)
                         (make-interval 0 2)))
#+END_SRC

#+RESULTS:
: (1 . 4)

* Exercise 2.9

In the case of addition and substraction, let's say we have two intervals: ~[x1, x2], [y1, y2]~

#+BEGIN_SRC
z = x + y = [x1+y1, x2+y2]
z2-z1 = x2-x1 + y2-y1 = width 1 + width 2

z = x - y = [x1-y2, x2-y1]
z2-z1 = x2-x1 + y2-y1 = width 1 + width 2
#+END_SRC

If it were a function of only the widths for multiplication and division, we would expect the resulting width to be the same for operations with same width input. We see that's not the case.

#+BEGIN_SRC scheme :noweb yes :results output
  <<ex_2.7>>

  (display "Mult\n")
  (display (mul-interval (make-interval 0 3)
                         (make-interval 2 7)))
  (display "\n")
  (display (mul-interval (make-interval 10 13)
                         (make-interval 0 5)))
  (display "\n")
  (display "Div\n")
  (display (div-interval (make-interval 1 3)
                         (make-interval 2 7)))
  (display "\n")
  (display (div-interval (make-interval 10 12)
                         (make-interval 1 6)))
#+END_SRC

#+RESULTS:
: Mult
: (0 . 21)
: (0 . 65)
: Div
: (0.14285714285714285 . 1.5)
: (1.6666666666666665 . 12.0)

* Exercise 2.10
#+BEGIN_SRC scheme :noweb yes :results output
  <<ex_2.7>>
  (define (div-interval x y)
    (if (< (* (lower-bound y) (upper-bound y)) 
           0)
        (error "Interval contains 0")
        (mul-interval x
                      (make-interval (/ 1.0 (upper-bound y))
                                     (/ 1.0 (lower-bound y))))))

  (display (div-interval (make-interval 10 12)
                         (make-interval 1 6)))
  (display "\n")
  (display (div-interval (make-interval 10 12)
                         (make-interval -2 6)))


#+END_SRC

#+RESULTS:
: ice-9/boot-9.scm:1669:16: In procedure raise-exception:
: Interval contains 0
: 
: Entering a new prompt.  Type `,bt' for a backtrace or `,q' to continue.
: scheme@(guile-user) [1]> 

* Exercise 2.11
We can construct a table with all the different possibilities. Here 0 means >= 0, 1 means < 0

| xl | xh | yl | yh |
|----+----+----+----|
|  0 |  0 |  0 |  0 |
|  0 |  0 |  0 |  1 |
|  0 |  0 |  1 |  0 |
|  0 |  0 |  1 |  1 |
|  0 |  1 |  0 |  0 |
|  0 |  1 |  0 |  1 |
|  0 |  1 |  1 |  0 |
|  0 |  1 |  1 |  1 |
|  1 |  0 |  0 |  0 |
|  1 |  0 |  0 |  1 |
|  1 |  0 |  1 |  0 |
|  1 |  0 |  1 |  1 |
|  1 |  1 |  0 |  0 |
|  1 |  1 |  0 |  1 |
|  1 |  1 |  1 |  0 |
|  1 |  1 |  1 |  1 |

But we have 16 cases, not 9 as Ben suggested. If we assume that the lower bound of an interval is less than the upper bound (which we have been doing so far), we can eliminate some of this cases, ending up with 9:

| xl | xh | yl | yh |
|----+----+----+----|
|  0 |  0 |  0 |  0 |
|  0 |  0 |  1 |  0 |
|  0 |  0 |  1 |  1 |
|  1 |  0 |  0 |  0 |
|  1 |  0 |  1 |  0 |
|  1 |  0 |  1 |  1 |
|  1 |  1 |  0 |  0 |
|  1 |  1 |  1 |  0 |
|  1 |  1 |  1 |  1 |

Having this, we can now each bound with only two multiplications (one for the lower bound, one for the upper bound), except for the case ~|  1 |  0 |  1 |  0 |~.

In this case need to test two different results for the lower bound, and the upper bound. Our final procedure is:

#+BEGIN_SRC scheme :noweb yes :results output
  <<ex_2.7>>
  (define (mul-interval x y)
    (let ((xl (lower-bound x))
          (xu (upper-bound x))
          (yl (lower-bound y))
          (yu (upper-bound y)))
      (cond ((and (>= xl 0)
                  (>= xu 0)
                  (>= yl 0)
                  (>= yu 0))
             (make-interval (* xl yl) (* xu yu)))
            ((and (>= xl 0)
                  (>= xu 0)
                  (< yl 0)
                  (>= yu 0))
             (make-interval (* xu yl) (* xu yu)))
            ((and (>= xl 0)
                  (>= xu 0)
                  (< yl 0)
                  (< yu 0))
             (make-interval (* xu yl) (* xl yu)))
            ((and (< xl 0)
                  (>= xu 0)
                  (>= yl 0)
                  (>= yu 0))
             (make-interval (* xl yl) (* xu yu)))
            ((and (< xl 0)
                  (>= xu 0)
                  (< yl 0)
                  (>= yu 0))
             (let ((l1 (* xl yu))
                   (l2 (* xu yl))
                   (u1 (* xl yl))
                   (u2 (* xu yu)))
               (make-interval (min l1 l2)
                              (max u1 u2))))
            ((and (< xl 0)
                  (>= xu 0)
                  (< yl 0)
                  (< yu 0))
             (make-interval (* xu yl) (* xl yu)))
            ((and (< xl 0)
                  (< xu 0)
                  (>= yl 0)
                  (>= yu 0))
             (make-interval (* xl yu) (* xu yl)))
            ((and (< xl 0)
                  (< xu 0)
                  (< yl 0)
                  (>= yu 0))
             (make-interval (* xl yu) (* xu yl)))
            ((and (< xl 0)
                  (< xu 0)
                  (< yl 0)
                  (< yu 0))
             (make-interval (* xu yu) (* xl yl))))))

  (display (mul-interval (make-interval -1 10)
                         (make-interval -2 3)))
#+END_SRC

#+RESULTS:
: (-20 . 30)

* Exercise 2.12
#+NAME: ex_2.12
#+BEGIN_SRC scheme :noweb yes
  <<ex_2.7>>
  (define (make-center-width c w)
    (make-interval (- c w) (+ c w)))

  (define (center i)
    (/ (+ (lower-bound i) (upper-bound i)) 2))

  (define (width i)
    (/ (- (upper-bound i) (lower-bound i)) 2))

  (define (make-center-percent c t)
    (make-interval (* c (- 1 (/ t 100)))
                   (* c (+ 1 (/ t 100)))))

  (define (percent i)
    (* (/ (width i) (center i)) 100))
#+END_SRC

* Exercise 2.17
#+BEGIN_SRC scheme
  (define (last-pair list)
    (if (null? (cdr list))
        (car list)
        (last-pair (cdr list))))

  (last-pair (list 23 72 149 34))
#+END_SRC

#+RESULTS:
: 34

* Exercise 2.18

#+BEGIN_SRC scheme 
    (define (reverse items)
      (if (null? items)
          items
          (append (reverse (cdr items)) 
                  (list (car items)))))

  (reverse (list 1 4 9 16 25))
#+END_SRC

#+RESULTS:
| 25 | 16 | 9 | 4 | 1 |

* Exercise 2.19
#+BEGIN_SRC scheme

  (define (except-first-denomination coin-values)
    (cdr coin-values))

  (define (first-denomination coin-values)
    (car coin-values))

  (define (no-more? coin-values)
    (null? coin-values))

  (define (cc amount coin-values)
    (cond ((= amount 0) 1)
          ((or (< amount 0) (no-more? coin-values)) 0)
          (else
           (+ (cc amount
                  (except-first-denomination coin-values))
              (cc (- amount
                     (first-denomination coin-values))
                  coin-values)))))


  (define us-coins (list 50 25 10 5 1))
  (define us-coins-r (list 1 5 10 25 50))

  (define uk-coins (list 100 50 20 10 5 2 1 0.5))



 (cc 100 us-coins)

#+END_SRC

#+RESULTS:
: 292

* Exercise 2.20
#+BEGIN_SRC scheme
  (define (same-parity . input)
    (define (same-parity-helper parity result input)
      (cond ((null? input)
             result)
            ((= (remainder (car input) 2) parity)
             (same-parity-helper parity
                                 (append result (list (car input)))
                                 (cdr input)))
            ((same-parity-helper parity
                                 result
                                 (cdr input)))))

    (same-parity-helper (remainder (car input) 2)
                        (list (car input))
                        (cdr input)))
  (same-parity 2 3 4 5 6 7 10)
#+END_SRC

#+RESULTS:
| 2 | 4 | 6 | 10 |

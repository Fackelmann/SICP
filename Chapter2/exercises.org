#+PROPERTY: header-args    :exports both
This is an org-mode file with ~scheme~ code blocks. If you clone this repo you can execute each block inside this file with ~C-c C-c~.

Because of some mysterious reason, results don't show up in the rendered github file. You can see them by opening the raw file.

* Table of Contents :TOC:
- [[#common][Common]]
- [[#exercise-21][Exercise 2.1]]
- [[#exercise-22][Exercise 2.2]]
- [[#exercise-23][Exercise 2.3]]
- [[#exercise-24][Exercise 2.4]]
- [[#exercise-25][Exercise 2.5]]
- [[#exercise-26][Exercise 2.6]]
- [[#exercise-27][Exercise 2.7]]
- [[#exercise-28][Exercise 2.8]]
- [[#exercise-29][Exercise 2.9]]
- [[#exercise-210][Exercise 2.10]]
- [[#exercise-211][Exercise 2.11]]
- [[#exercise-212][Exercise 2.12]]
- [[#exercise-217][Exercise 2.17]]
- [[#exercise-218][Exercise 2.18]]
- [[#exercise-219][Exercise 2.19]]
- [[#exercise-220][Exercise 2.20]]
- [[#exercise-221][Exercise 2.21]]
- [[#exercise-222][Exercise 2.22]]
- [[#exercise-223][Exercise 2.23]]
- [[#exercise-224][Exercise 2.24]]
- [[#exercise-225][Exercise 2.25]]
- [[#exercise-226][Exercise 2.26]]
- [[#exercise-227][Exercise 2.27]]
- [[#exercise-228][Exercise 2.28]]
- [[#exercise-229][Exercise 2.29]]
- [[#exercise-230][Exercise 2.30]]
- [[#exercise-231][Exercise 2.31]]
- [[#exercise-232][Exercise 2.32]]
- [[#exercise-233][Exercise 2.33]]
- [[#exercise-234][Exercise 2.34]]
- [[#exercise-235][Exercise 2.35]]
- [[#exercise-236][Exercise 2.36]]
- [[#exercise-237][Exercise 2.37]]
- [[#exercise-238][Exercise 2.38]]
- [[#exercise-239][Exercise 2.39]]
- [[#exercise-240][Exercise 2.40]]
- [[#exercise-241][Exercise 2.41]]
- [[#exercise-242][Exercise 2.42]]
- [[#exercise-243][Exercise 2.43]]
- [[#exercise-244][Exercise 2.44]]
- [[#exercise-245][Exercise 2.45]]
- [[#exercise-246][Exercise 2.46]]
- [[#exercise-247][Exercise 2.47]]
- [[#exercise-248][Exercise 2.48]]
- [[#exercise-249][Exercise 2.49]]
- [[#exercise-250][Exercise 2.50]]
- [[#exercise-251][Exercise 2.51]]
- [[#exercise-253][Exercise 2.53]]
- [[#exercise-254][Exercise 2.54]]
- [[#exercise-255][Exercise 2.55]]
- [[#differentiator][Differentiator]]
- [[#exercise-256][Exercise 2.56]]
- [[#exercise-257][Exercise 2.57]]
- [[#exercise-258][Exercise 2.58]]
- [[#exercise-259][Exercise 2.59]]
- [[#exercise-260][Exercise 2.60]]
- [[#exercise-261][Exercise 2.61]]
- [[#exercise-262][Exercise 2.62]]
- [[#exercise-263][Exercise 2.63]]
- [[#exercise-264][Exercise 2.64]]
- [[#exercise-265][Exercise 2.65]]
- [[#exercise-266][Exercise 2.66]]
- [[#exercise-267][Exercise 2.67]]
- [[#exercise-267-1][Exercise 2.67]]
- [[#exercise-268][Exercise 2.68]]
- [[#exercise-269][Exercise 2.69]]
- [[#exercise-270][Exercise 2.70]]
- [[#exercise-271][Exercise 2.71]]
- [[#exercise-272][Exercise 2.72]]
- [[#exercise-273][Exercise 2.73]]
- [[#exercise-274][Exercise 2.74]]
- [[#exercise-275][Exercise 2.75]]
- [[#exercise-276][Exercise 2.76]]
  - [[#which-changes-must-be-made-to-a-system-in-order-to-add-new-types-or-new-operations][Which changes must be made to a system in order to add new types or new operations?]]
    - [[#generic-operations-with-explicit-dispatch][Generic operations with explicit dispatch]]
    - [[#data-directed-style][Data-directed style]]
    - [[#message-passing-style][Message-passing style]]
  - [[#which-organizations-would-be-most-appropriate-for-a-system-in-which-new-types-must-often-be-added][Which organizations would be most appropriate for a system in which new types must often be added?]]
  - [[#which-would-be-most-appropriate-for-a-system-in-which-new-operations-must-often-be-added][Which would be most appropriate for a system in which new operations must often be added?]]

* Common

Defining common functions here, so we don't need to repeat them over all the code blocks. 
#+NAME: common_block
#+BEGIN_SRC scheme
  (define (square x)
    (* x x))

  (define (gcd a b)
    (if (= b 0)
        a
        (gcd b (remainder a b))))

  (define (power x n)
    (if (= n 0)
        1
        (* x (power x (- n 1)))))
#+END_SRC


* Exercise 2.1
#+BEGIN_SRC scheme :noweb yes :results output
  <<common_block>>
  (define (numer x) (car x))

  (define (denom x) (cdr x))

  (define (print-rat x)
    (display "\n")
    (display (numer x))
    (display "/")
    (display (denom x)))

  (define (make-rat n d)
    (define (is-positive? n d)
      (cond ((and (> n 0) (< d 0))
             -1)
            ((and (< n 0) (> d 0))
             -1)
            (else
             1)))
    (let ((g (gcd n d))
          (sign (is-positive? n d)))
      (cons (* sign (/ n g)) (* sign (/ d g)))))

  (print-rat (make-rat 3 -6))
  (print-rat (make-rat -3 6))
  (print-rat (make-rat -3 -6))
  (print-rat (make-rat 3 6))

#+END_SRC

#+RESULTS:
: 
: -1/2
: -1/2
: 1/2
: 1/2

* Exercise 2.2

#+NAME: ex_2.2
#+BEGIN_SRC scheme :results output
  (define (make-segment start end)
    (cons start end))

  (define (start-segment segment)
    (car segment))

  (define (end-segment segment)
    (cdr segment))

  (define (make-point x y)
    (cons x y))

  (define (x-point point)
    (car point))

  (define (y-point point)
    (cdr point))

  (define (print-point p)
    (display "\n")
    (display "(")
    (display (x-point p))
    (display ",")
    (display (y-point p))
    (display ")"))

  (define (midpoint-segment segment)
    (let ((start (start-segment segment))
          (end (end-segment segment)))
      (let ((midx (/ (+ (x-point start)
                        (x-point end))
                     2))
            (midy (/ (+ (y-point start)
                        (y-point end))
                     2)))
        (make-point midx midy))))

  (define my-segment (make-segment (make-point 1 1)
                                   (make-point 2 2)))

  (define midpoint (midpoint-segment my-segment))

;;  (print-point midpoint)
#+END_SRC

#+RESULTS:
: 
: (3/2,3/2)

* Exercise 2.3

#+BEGIN_SRC scheme :noweb yes :results output
  <<ex_2.2>>
  ;; Implement rectangles with sides parallel to the axis for now
  ;; Generalizing it adds complexity without addin much value (IMO) to this exercise
  (define (rectangle lower_left upper_right)
    (cons lower_left upper_right))

  (define (rect-ll rectangle)
    (car rectangle))

  (define (rect-ur rectangle)
    (cdr rectangle))

  (define (rect-perimeter rectangle)
    (* (+ (- (x-point (rect-ur rectangle))
             (x-point (rect-ll rectangle)))
          (- (y-point (rect-ur rectangle))
             (y-point (rect-ll rectangle))))
       2))

  (define (rect-area rectangle)
    (* (- (x-point (rect-ur rectangle))
          (x-point (rect-ll rectangle)))
       (- (y-point (rect-ur rectangle))
          (y-point (rect-ll rectangle)))))

  (define my-rectangle (rectangle (make-point 1 0)
                                  (make-point 10 2)))

  (display "\n")
  (display (rect-perimeter my-rectangle))
  (display "\n")
  (display (rect-area my-rectangle))
#+END_SRC

#+RESULTS:
: 
: 22
: 18

* Exercise 2.4
Check that it works as expected:
#+BEGIN_SRC scheme
(car (cons 3 2))
(car (lambda (m) (m 3 2)))
((lambda (p q) p) 3 2)
3
#+END_SRC

And ~cdr~ implementation:
#+BEGIN_SRC scheme
  (define (cdr z)
    (z (lambda (p q) q)))
#+END_SRC

* Exercise 2.5

#+BEGIN_SRC scheme :noweb yes :results output
  <<common_block>>
  (define (cons a b)
    (* (power 2 a)
       (power 3 b)))

  (define (max-exponent n a)
    (if (= 0 (remainder n a))
        (+ 1 (max-exponent (/ n a)  a))
        0))

  (define (car z)
    (max-exponent z 2))

  (define (cdr z)
    (max-exponent z 3))

  ;; Test
  ;; It seems that Guile doesn't suppor assert
  ;; strange
  ;; (let ((list (cons 5 7)))
  ;;   (assert (= (car list) 5))
  ;;   (assert (= (cdr list) 7)))

  ;; Test

  (let ((list (cons 5 7)))
    (display "\n")
    (display (= (car list) 5))
    (display "\n")
    (display (= (cdr list) 7)))

  (let ((list (cons 127 1)))
    (display "\n")
    (display (= (car list) 127))
    (display "\n")
    (display (= (cdr list) 1)))

  (let ((list (cons 21 32)))
    (display "\n")
    (display (= (car list) 21))
    (display "\n")
    (display (= (cdr list) 32)))
#+END_SRC

#+RESULTS:
: 
: #t
: #t
: #t
: #t
: #t
: #t

* Exercise 2.6

Let's start by evaluating ~(add-1 zero)~
#+BEGIN_SRC scheme
(add-1 zero)
(lambda (f) (lambda (x) (f ((zero f) x))))
#+END_SRC

And evaluating ~(zero f)~

#+BEGIN_SRC scheme
(zero f)
(lambda (f) (lambda (x) x))
(lambda (x) x)
#+END_SRC

Substituting:

#+BEGIN_SRC scheme
(lambda (f) (lambda (x) (f x)))
#+END_SRC

So one is:
#+BEGIN_SRC scheme
(define one (lambda (f) (lambda (x) (f x))))
#+END_SRC

Similarly if we evaluate ~(add-1 1)~, the number two will be:

#+BEGIN_SRC scheme
(define two (lambda (f) (lambda (x) (f (f x)))))
#+END_SRC

We can see that a number N is defined by a lambda expression in which a lambda function is applied N times to another lambda expression.

* Exercise 2.7
#+NAME: ex_2.7
#+BEGIN_SRC scheme
  (define (make-interval a b)
    (cons a b))

  (define (upper-bound interval)
    (cdr interval))

  (define (lower-bound interval)
    (car interval))

  (define (add-interval x y)
    (make-interval (+ (lower-bound x) (lower-bound y))
                   (+ (upper-bound x) (upper-bound y))))

  (define (mul-interval x y)
    (let ((p1 (* (lower-bound x) (lower-bound y)))
          (p2 (* (lower-bound x) (upper-bound y)))
          (p3 (* (upper-bound x) (lower-bound y)))
          (p4 (* (upper-bound x) (upper-bound y))))
      (make-interval (min p1 p2 p3 p4)
                     (max p1 p2 p3 p4))))

  (define (div-interval x y)
    (mul-interval x
                  (make-interval (/ 1.0 (upper-bound y))
                                 (/ 1.0 (lower-bound y)))))
#+END_SRC

#+RESULTS: ex_2.7
: #<unspecified>

* Exercise 2.8

#+BEGIN_SRC scheme :noweb yes :results output
  <<ex_2.7>>
  (define (sub-interval x y)
    (make-interval (- (lower-bound x) (upper-bound y))
                   (- (upper-bound x) (lower-bound y))))

  (display (sub-interval (make-interval 3 4)
                         (make-interval 0 2)))
#+END_SRC

#+RESULTS:
: (1 . 4)

* Exercise 2.9

In the case of addition and substraction, let's say we have two intervals: ~[x1, x2], [y1, y2]~

#+BEGIN_SRC
z = x + y = [x1+y1, x2+y2]
z2-z1 = x2-x1 + y2-y1 = width 1 + width 2

z = x - y = [x1-y2, x2-y1]
z2-z1 = x2-x1 + y2-y1 = width 1 + width 2
#+END_SRC

If it were a function of only the widths for multiplication and division, we would expect the resulting width to be the same for operations with same width input. We see that's not the case.

#+BEGIN_SRC scheme :noweb yes :results output
  <<ex_2.7>>

  (display "Mult\n")
  (display (mul-interval (make-interval 0 3)
                         (make-interval 2 7)))
  (display "\n")
  (display (mul-interval (make-interval 10 13)
                         (make-interval 0 5)))
  (display "\n")
  (display "Div\n")
  (display (div-interval (make-interval 1 3)
                         (make-interval 2 7)))
  (display "\n")
  (display (div-interval (make-interval 10 12)
                         (make-interval 1 6)))
#+END_SRC

#+RESULTS:
: Mult
: (0 . 21)
: (0 . 65)
: Div
: (0.14285714285714285 . 1.5)
: (1.6666666666666665 . 12.0)

* Exercise 2.10
#+BEGIN_SRC scheme :noweb yes :results output
  <<ex_2.7>>
  (define (div-interval x y)
    (if (< (* (lower-bound y) (upper-bound y)) 
           0)
        (error "Interval contains 0")
        (mul-interval x
                      (make-interval (/ 1.0 (upper-bound y))
                                     (/ 1.0 (lower-bound y))))))

  (display (div-interval (make-interval 10 12)
                         (make-interval 1 6)))
  (display "\n")
  (display (div-interval (make-interval 10 12)
                         (make-interval -2 6)))


#+END_SRC

#+RESULTS:
: ice-9/boot-9.scm:1669:16: In procedure raise-exception:
: Interval contains 0
: 
: Entering a new prompt.  Type `,bt' for a backtrace or `,q' to continue.
: scheme@(guile-user) [1]> 

* Exercise 2.11
We can construct a table with all the different possibilities. Here 0 means >= 0, 1 means < 0

| xl | xh | yl | yh |
|----+----+----+----|
|  0 |  0 |  0 |  0 |
|  0 |  0 |  0 |  1 |
|  0 |  0 |  1 |  0 |
|  0 |  0 |  1 |  1 |
|  0 |  1 |  0 |  0 |
|  0 |  1 |  0 |  1 |
|  0 |  1 |  1 |  0 |
|  0 |  1 |  1 |  1 |
|  1 |  0 |  0 |  0 |
|  1 |  0 |  0 |  1 |
|  1 |  0 |  1 |  0 |
|  1 |  0 |  1 |  1 |
|  1 |  1 |  0 |  0 |
|  1 |  1 |  0 |  1 |
|  1 |  1 |  1 |  0 |
|  1 |  1 |  1 |  1 |

But we have 16 cases, not 9 as Ben suggested. If we assume that the lower bound of an interval is less than the upper bound (which we have been doing so far), we can eliminate some of this cases, ending up with 9:

| xl | xh | yl | yh |
|----+----+----+----|
|  0 |  0 |  0 |  0 |
|  0 |  0 |  1 |  0 |
|  0 |  0 |  1 |  1 |
|  1 |  0 |  0 |  0 |
|  1 |  0 |  1 |  0 |
|  1 |  0 |  1 |  1 |
|  1 |  1 |  0 |  0 |
|  1 |  1 |  1 |  0 |
|  1 |  1 |  1 |  1 |

Having this, we can now each bound with only two multiplications (one for the lower bound, one for the upper bound), except for the case ~|  1 |  0 |  1 |  0 |~.

In this case need to test two different results for the lower bound, and the upper bound. Our final procedure is:

#+BEGIN_SRC scheme :noweb yes :results output
  <<ex_2.7>>
  (define (mul-interval x y)
    (let ((xl (lower-bound x))
          (xu (upper-bound x))
          (yl (lower-bound y))
          (yu (upper-bound y)))
      (cond ((and (>= xl 0)
                  (>= xu 0)
                  (>= yl 0)
                  (>= yu 0))
             (make-interval (* xl yl) (* xu yu)))
            ((and (>= xl 0)
                  (>= xu 0)
                  (< yl 0)
                  (>= yu 0))
             (make-interval (* xu yl) (* xu yu)))
            ((and (>= xl 0)
                  (>= xu 0)
                  (< yl 0)
                  (< yu 0))
             (make-interval (* xu yl) (* xl yu)))
            ((and (< xl 0)
                  (>= xu 0)
                  (>= yl 0)
                  (>= yu 0))
             (make-interval (* xl yl) (* xu yu)))
            ((and (< xl 0)
                  (>= xu 0)
                  (< yl 0)
                  (>= yu 0))
             (let ((l1 (* xl yu))
                   (l2 (* xu yl))
                   (u1 (* xl yl))
                   (u2 (* xu yu)))
               (make-interval (min l1 l2)
                              (max u1 u2))))
            ((and (< xl 0)
                  (>= xu 0)
                  (< yl 0)
                  (< yu 0))
             (make-interval (* xu yl) (* xl yu)))
            ((and (< xl 0)
                  (< xu 0)
                  (>= yl 0)
                  (>= yu 0))
             (make-interval (* xl yu) (* xu yl)))
            ((and (< xl 0)
                  (< xu 0)
                  (< yl 0)
                  (>= yu 0))
             (make-interval (* xl yu) (* xu yl)))
            ((and (< xl 0)
                  (< xu 0)
                  (< yl 0)
                  (< yu 0))
             (make-interval (* xu yu) (* xl yl))))))

  (display (mul-interval (make-interval -1 10)
                         (make-interval -2 3)))
#+END_SRC

#+RESULTS:
: (-20 . 30)

* Exercise 2.12
#+NAME: ex_2.12
#+BEGIN_SRC scheme :noweb yes
  <<ex_2.7>>
  (define (make-center-width c w)
    (make-interval (- c w) (+ c w)))

  (define (center i)
    (/ (+ (lower-bound i) (upper-bound i)) 2))

  (define (width i)
    (/ (- (upper-bound i) (lower-bound i)) 2))

  (define (make-center-percent c t)
    (make-interval (* c (- 1 (/ t 100)))
                   (* c (+ 1 (/ t 100)))))

  (define (percent i)
    (* (/ (width i) (center i)) 100))
#+END_SRC

* Exercise 2.17
#+BEGIN_SRC scheme
  (define (last-pair list)
    (if (null? (cdr list))
        (car list)
        (last-pair (cdr list))))

  (last-pair (list 23 72 149 34))
#+END_SRC

#+RESULTS:
: 34

* Exercise 2.18

#+BEGIN_SRC scheme 
    (define (reverse items)
      (if (null? items)
          items
          (append (reverse (cdr items)) 
                  (list (car items)))))

  (reverse (list 1 4 9 16 25))
#+END_SRC

#+RESULTS:
| 25 | 16 | 9 | 4 | 1 |

* Exercise 2.19
#+BEGIN_SRC scheme

  (define (except-first-denomination coin-values)
    (cdr coin-values))

  (define (first-denomination coin-values)
    (car coin-values))

  (define (no-more? coin-values)
    (null? coin-values))

  (define (cc amount coin-values)
    (cond ((= amount 0) 1)
          ((or (< amount 0) (no-more? coin-values)) 0)
          (else
           (+ (cc amount
                  (except-first-denomination coin-values))
              (cc (- amount
                     (first-denomination coin-values))
                  coin-values)))))


  (define us-coins (list 50 25 10 5 1))
  (define us-coins-r (list 1 5 10 25 50))

  (define uk-coins (list 100 50 20 10 5 2 1 0.5))



 (cc 100 us-coins)

#+END_SRC

#+RESULTS:
: 292

* Exercise 2.20
Dotted-tail notation. Arbitrary number  of arguments
#+BEGIN_SRC scheme
  (define (same-parity . input)
    (define (same-parity-helper parity result input)
      (cond ((null? input)
             result)
            ((= (remainder (car input) 2) parity)
             (same-parity-helper parity
                                 (append result (list (car input)))
                                 (cdr input)))
            ((same-parity-helper parity
                                 result
                                 (cdr input)))))

    (same-parity-helper (remainder (car input) 2)
                        (list (car input))
                        (cdr input)))
  (same-parity 2 3 4 5 6 7 10)
#+END_SRC

#+RESULTS:
| 2 | 4 | 6 | 10 |

* Exercise 2.21

Without map:
#+BEGIN_SRC scheme
  (define (square-list items)
    (if (null? items)
        '()
        (cons (* (car items) (car items))
              (square-list (cdr items)))))
  (square-list (list 1 2 3 4))
#+END_SRC

#+RESULTS:
| 1 | 4 | 9 | 16 |

With map:
#+BEGIN_SRC scheme
  (define (square-list items)
    (map (lambda (x) (* x x))
         items))
  (square-list (list 1 2 3 4))
#+END_SRC

#+RESULTS:
| 1 | 4 | 9 | 16 |

* Exercise 2.22

The first implementation produces the answer in the reversed order becasue we keep are adding the square car of the list and adding it to the answer, and then iterating over the cdr of the list.

#+BEGIN_SRC scheme
  (define (square x)
    (* x x))
  (define (square-list items)
    (define (iter things answer)
      (if (null? things)
          answer
          (iter (cdr things)
                (cons answer
                      (square (car things))))))
    (iter items '()))
    (square-list (list 1 2 3 4))
#+END_SRC

This will produce:
((((() . 1) . 4) . 9) . 16)

The reason is that now with cons we are not construction a correct list.
In the first iteration we create a pair ('() . 1). Then we make this the first element of the next pair, (('() . 1) . 4), and so on.
This construction has the form:

(cons (cons (cons nil 1) 4) 9)...

When a correct list has the form (abbreviated to 9 elements):
(cons 1 (cons 4 (cons 9 nil))) 

* Exercise 2.23

#+BEGIN_SRC scheme :results output
  (define (for-each proc items)
    (cond ((null? items)
           #t)
          ((proc (car items))
           (for-each proc (cdr items)))))

  (for-each (lambda (x) (display "\n") (display x))
            (list 57 321 88))
#+END_SRC

#+RESULTS:
: 
: 57
: 321
: 88

* Exercise 2.24
Result:
#+BEGIN_SRC 
(1 (2 (3 4)))
#+END_SRC

Box pointer structure
#+BEGIN_SRC 
(1 (2 (3 4))
             +---+---+                  +---+---+     +---+---+
        ---->| * | *-+----------------->| * | *-+---->| * | / |
             +---+---+                  +---+---+     +---+---=
               |                          |             |
               V                          V             V
             +---+                      +---+   (3 4) +---+---+    +---+---+
             | 1 |                      | 2 |     --->| * | *-+--->| * | / |
             +---+                      +---+         +---+---+    +---+---+
                                                        |            |
                                                        V            V
                                                      +---+        +---+
                                                      | 3 |        | 4 |
                                                      +---+        +---+
#+END_SRC

Tree structure
#+BEGIN_SRC 
            (1 (2 (3 4)))
                /\
               /  \
              1  (2 (3 4))
                   /\
                  /  \
                 2  (3 4)
                     /\
                    3  4
#+END_SRC

* Exercise 2.25
#+BEGIN_SRC scheme
(define list1 (list 1 3 (list 5 7) 9))
(car (cdr (car (cdr (cdr list1)))))

(define list2 (list (list 7)))
(car (car list2))

(define list3 (list 1 (list 2 (list 3 (list 4 (list 5 (list 6 7)))))))
(car (cdr (car (cdr (car (cdr (car (cdr (car (cdr (car (cdr list3))))))))))))
#+END_SRC

* Exercise 2.26

#+BEGIN_SRC 
(append x y)
(1 2 3 4 5 6)
#+END_SRC

#+BEGIN_SRC 
(cons x y)
((1 2 3) 4 5 6)
#+END_SRC

#+BEGIN_SRC 
(list x y)
((1 2 3) (4 5 6))
#+END_SRC

* Exercise 2.27

~deep-reverse~ is similar to ~reverse~, from exercise 2.18. The only difference is that if one of the branches is a tree (this is, a pair), we recursively apply it to those elements as well, to reverse them within the subtree.

#+BEGIN_SRC scheme 
  (define (deep-reverse items)
    (cond ((null? items)
           items)
          ((pair? (car items))
           (append (deep-reverse (cdr items)) 
                   (list (deep-reverse (car items)))))
          ((append (deep-reverse (cdr items)) 
                   (list (car items))))))

  (define x (list (list 1 2) (list 3 4) 5 6 ))
  (deep-reverse x)
#+END_SRC

#+RESULTS:
| 6 | 5 | (4 3) | (2 1) |

* Exercise 2.28

#+NAME: fringe
#+BEGIN_SRC scheme
  (define (fringe items)
    (cond ((null? items)
           items)
          ((not (pair? items))
           (list items))
          ((append (fringe (car items))
                   (fringe (cdr items))))))


  (define x (list (list 1 2) (list 3 4)))

  (fringe x)
#+END_SRC
#+RESULTS:
| 1 | 2 | 3 | 4 |

* Exercise 2.29

#+NAME: mobile_basics
#+BEGIN_SRC scheme
  (define (make-mobile left right)
    (list left right))
  (define (make-branch length structure)
    (list length structure))

  (define (left-branch mobile)
    (list-ref mobile 0))
  (define (right-branch mobile)
    (list-ref mobile 1))
  (define (branch-length branch)
    (list-ref branch 0))
  (define (branch-structure branch)
    (list-ref branch 1))

  (define (total-weight mobile)
    (if (not (pair? mobile))
        mobile
        (+ (total-weight (branch-structure (left-branch mobile)))
           (total-weight (branch-structure (right-branch mobile))))))



  (define my-mobile (make-mobile (make-branch 2 3)
                                 (make-branch 1 (make-mobile (make-branch 1 2)
                                                             (make-branch 3 5)))))
  (total-weight my-mobile)

#+END_SRC

#+RESULTS:
: 10

#+BEGIN_SRC scheme :noweb yes :results output
  <<mobile_basics>>

  (define (is-balanced? mobile)  
    (if (not (pair? mobile))
        #t
        (let ((mobile-right-branch (right-branch mobile))
              (mobile-left-branch (left-branch mobile)))
          (and (= (* (total-weight (branch-structure mobile-left-branch))
                     (branch-length mobile-left-branch))
                  (* (total-weight (branch-structure mobile-right-branch))
                     (branch-length mobile-right-branch)))
               (is-balanced? (branch-structure mobile-left-branch))
               (is-balanced? (branch-structure mobile-right-branch))))))

  (define my-mobile (make-mobile (make-branch 2 3)
                                 (make-branch 1 (make-mobile (make-branch 1 2)
                                                             (make-branch 3 5)))))
  (display (is-balanced? my-mobile))

  (define my-mobile-balanced (make-mobile (make-branch 2 3)
                                          (make-branch 1 (make-mobile (make-branch 1 2)
                                                                      (make-branch 0.5 4)))))
  (display "\n")
  (display (is-balanced? my-mobile-balanced))
#+END_SRC

#+RESULTS:
: #f
: #t

If we changed the constructors from ~list~ to ~cons~, we'd need to change the accesors and the pair? check at the programs. Maybe create a ~is-weight?~ procedure so we don't depend on the internal representation of the mobile.

* Exercise 2.30
Direct implementation:
#+BEGIN_SRC scheme
  (define (square-tree tree)
    (cond ((null? tree) '())
          ((not (pair? tree)) (* tree tree))
          (else (cons (square-tree (car tree))
                      (square-tree (cdr tree))))))

  (square-tree
   (list 1
         (list 2 (list 3 4) 5)
         (list 6 7)))
#+END_SRC

#+RESULTS:
| 1 | (4 (9 16) 25) | (36 49) |

Map implementation:
#+BEGIN_SRC scheme
  (define (square-tree tree)
    (map (lambda (sub-tree)
           (if (not (pair? sub-tree))
               (* sub-tree sub-tree)
               (square-tree sub-tree)))
         tree))
  (square-tree
   (list 1
         (list 2 (list 3 4) 5)
         (list 6 7)))

#+END_SRC

#+RESULTS:
| 1 | (4 (9 16) 25) | (36 49) |

* Exercise 2.31
#+BEGIN_SRC scheme
  (define (square x)
    (* x x))
  
(define (tree-map proc tree)
    (map (lambda (sub-tree)
           (if (not (pair? sub-tree))
               (proc sub-tree)
               (tree-map proc sub-tree)))
         tree))


  (define (square-tree tree) (tree-map square tree))
  (square-tree
   (list 1
         (list 2 (list 3 4) 5)
         (list 6 7)))
#+END_SRC

#+RESULTS:
| 1 | (4 (9 16) 25) | (36 49) |

* Exercise 2.32

We start by specifying that the subsets of an empty set, is the empty set: ~(())~

Then, the other insight is that the subsets can be obtained by:
- Getting the subsets of the set minus one element (~let ((rest (substes (cdr s))))...~)
- And adding the element to every subset we obtained (also including the subsets without the element)

For example, let's say que have ~(1 2 3)~

If we find the subsets of ~(2 3)~ we have: ~(() (2) (3) (2 3))~
Now if we add 1 to those subsets ~((1) (1 2) (1 3) (1 2 3))~
Putting all together ~(() (2) (3) (2 3) (1) (1 2) (1 3) (1 2 3))~

#+BEGIN_SRC scheme
  (define (subsets s)
    (if (null? s)
        (list '())
        (let ((rest (subsets (cdr s))))
          (append rest
                  (map
                   (lambda (l) (cons (car s) l))
                   rest)))))

  (subsets (list 1 2 3))
#+END_SRC

#+RESULTS:
|---+---+---|
| 3 |   |   |
| 2 |   |   |
| 2 | 3 |   |
| 1 |   |   |
| 1 | 3 |   |
| 1 | 2 |   |
| 1 | 2 | 3 |

* Exercise 2.33
#+NAME: sequence_procs
#+BEGIN_SRC scheme
  (define (accumulate op initial sequence)
    (if (null? sequence)
        initial
        (op (car sequence)
            (accumulate op initial (cdr sequence)))))

  (define (filter predicate sequence)
    (cond ((null? sequence) '())
          ((predicate (car sequence))
           (cons (car sequence)
                 (filter predicate (cdr sequence))))
          (else (filter predicate (cdr sequence)))))
  (define (enumerate-interval low high)
    (if (> low high)
        '()
        (cons low (enumerate-interval (+ low 1) high))))
#+END_SRC

#+BEGIN_SRC scheme :noweb yes :results output
  <<sequence_procs>>

  (define (map p sequence)
    (accumulate (lambda (x y) (cons (p x) y)) '() sequence))

  (define (append seq1 seq2)
    (accumulate cons seq2 seq1))

  (define (length sequence)
    (accumulate (lambda (x y) (+ y 1)) 0 sequence))

  (display (map (lambda (x) (+ 2 x)) (list 1 2 3)))
  (display "\n")
  (display (append (list 1 2 3) (list 4 5 6)))
  (display "\n")
  (display (length (list 1 2 3 4 5)))

#+END_SRC

#+RESULTS:
: (3 4 5)
: (1 2 3 4 5 6)
: 5

* Exercise 2.34
Evaluate polynomial with Horner's rule:

#+BEGIN_SRC scheme :noweb yes
  <<sequence_procs>>

  (define (horner-eval x coefficient-sequence)
    (accumulate (lambda (this-coeff higher-terms)
                  (+ this-coeff
                     (* x higher-terms)))
                0
                coefficient-sequence))

  ;; 1 + 3x + 5x^3 + x^5 at x = 2
  (horner-eval 2 (list 1 3 0 5 0 1))
#+END_SRC

#+RESULTS:
: 79

* Exercise 2.35

With ~fringe~ (~enumerate-tree~) it's easy to do. Not sure how ~map~ (hint) helps here.

#+BEGIN_SRC scheme :noweb yes
  <<fringe>>
  <<sequence_procs>>
  (define (count-leaves t)
    (accumulate (lambda (x y) (+ 1 y)) 0 (fringe t)))

  (define x (list (list 1 2) (list 3 4)))
  (count-leaves x)
#+END_SRC

#+RESULTS:
: 4

* Exercise 2.36

#+NAME: accumulate-n
#+BEGIN_SRC scheme :noweb yes
  <<sequence_procs>>
  (define (accumulate-n op init seqs)
    (if (null? (car seqs))
        '()
        (cons (accumulate op init (map (lambda (x) (car x))
                                       seqs))
              (accumulate-n op init (map (lambda (x) (cdr x))
                                         seqs)))))


  (define s (list (list 1 2 3) (list 4 5 6) (list 7 8 9) (list 10 11 12)))

  (accumulate-n + 0 s)
#+END_SRC

#+RESULTS:
| 22 | 26 | 30 |

* Exercise 2.37

#+BEGIN_SRC scheme :noweb yes :results output
  <<sequence_procs>>
  <<accumulate-n>>

  (define (dot-product v w)
    (accumulate + 0 (map * v w)))

  (define (matrix-*-vector m v)
    (map (lambda (mvec) (dot-product mvec v))  m))

  (define (transpose mat)
    (accumulate-n cons '() mat))

  (define (matrix-*-matrix m n)
    (let ((cols (transpose n)))
      (map (lambda (mvec) (matrix-*-vector cols mvec)) m)))

  (define m (list (list 1 2 3 4) (list 4 5 6 6) (list 6 7 8 9)))
  (define square-m (list (list 1 2 3) (list 4 5 6) (list 7 8 9)))
  (define v (list 7 5 3 1))

  (display "matrix * vector\n")
  (display (matrix-*-vector m v))
  (display "\ntranspose\n")
  (display (transpose m))
  (display "\nmatrix*matrix\n")
  (display (matrix-*-matrix square-m square-m))
#+END_SRC

#+RESULTS:
: matrix * vector
: (30 77 110)
: transpose
: ((1 4 6) (2 5 7) (3 6 8) (4 6 9))
: matrix*matrix
: ((30 36 42) (66 81 96) (102 126 150))

* Exercise 2.38

#+NAME: fold-left
#+BEGIN_SRC scheme :noweb yes :results output
  <<sequence_procs>>

  (define (fold-left op initial sequence)
    (define (iter result rest)
      (if (null? rest)
          result
          (iter (op result (car rest))
                (cdr rest))))
    (iter initial sequence))

  (display (accumulate / 1 (list 1 2 3)))
  (display "\n")
  (display (fold-left / 1 (list 1 2 3)))
  (display "\n")
  (display (accumulate list '() (list 1 2 3)))
  (display "\n")
  (display (fold-left list '() (list 1 2 3)))
  (display "\n")
  (display (accumulate + 3 (list 1 2 3)))
  (display "\n")
  (display (fold-left + 3 (list 1 2 3)))
  (display "\n")
  (display (accumulate * 0.5 (list 1 2 3)))
  (display "\n")
  (display (fold-left * 0.5 (list 1 2 3)))
  (display "\n")
#+END_SRC

#+RESULTS: fold-left
: 3/2
: 1/6
: (1 (2 (3 ())))
: (((() 1) 2) 3)
: 9
: 9
: 3.0
: 3.0

#+BEGIN_SRC
(fold-right / 1 (list 1 2 3))
(/ 1 (fold-right / 1 (list 2 3))
(/ 1 (/ 2 (fold-right / 1 (list 3))))
(/ 1 (/ 2 (/ 3 (accumulate / 1 '()))))
(/ 1 (/ 2 (/ 3 1)))
;; 1 / (2 / (3 /1))
;; 1 op (2 op (3 op initial))

(fold-left / 1 (list 1 2 3))
(iter 1 (list 1 2 3))
(iter (/ 1 1) (list 2 3))
(iter (/ (/ 1 1) 2) (list 3))
(iter (/ (/ (/1 1) 2) 3) '())
(/ (/ (/1 1) 2) 3)
;; ((1/1) / 2) /3
;; ((1 op initial) op 2) op 3
#+END_SRC

We need 2 properties:
- Commutativity, because the initial value can be applied to the first or last element of the list
- Associativity, because the order in which we perform the operations changes between fold-left and fold-right

An example of an ~op~ that would satisfy this is ~+~

* Exercise 2.39

First, trying to understand that flatmap and lambda func:

#+BEGIN_SRC scheme :noweb yes
  <<sequence_procs>>
  (define (enumerate-interval low high)
    (if (> low high)
        '()
        (cons low (enumerate-interval (+ low 1) high))))


  (accumulate append
              '()
              (map (lambda (i)
                     (map (lambda (j) (list i j))
                          (enumerate-interval 1 (- i 1))))
                   (enumerate-interval 1 10)))

  (enumerate-interval 1 10)

  (map (lambda (i)
         (map (lambda (j) (list i j))
              (enumerate-interval 1 (- i 1))))
       (enumerate-interval 1 10))
#+END_SRC

#+RESULTS:
|--------+--------+--------+--------+--------+--------+--------+--------+--------|
| (2 1)  |        |        |        |        |        |        |        |        |
| (3 1)  | (3 2)  |        |        |        |        |        |        |        |
| (4 1)  | (4 2)  | (4 3)  |        |        |        |        |        |        |
| (5 1)  | (5 2)  | (5 3)  | (5 4)  |        |        |        |        |        |
| (6 1)  | (6 2)  | (6 3)  | (6 4)  | (6 5)  |        |        |        |        |
| (7 1)  | (7 2)  | (7 3)  | (7 4)  | (7 5)  | (7 6)  |        |        |        |
| (8 1)  | (8 2)  | (8 3)  | (8 4)  | (8 5)  | (8 6)  | (8 7)  |        |        |
| (9 1)  | (9 2)  | (9 3)  | (9 4)  | (9 5)  | (9 6)  | (9 7)  | (9 8)  |        |
| (10 1) | (10 2) | (10 3) | (10 4) | (10 5) | (10 6) | (10 7) | (10 8) | (10 9) |


Let's try the permutation example
#+NAME: permutation
#+BEGIN_SRC scheme :noweb yes
  <<sequence_procs>>
  (define (flatmap proc seq)
    (accumulate append '() (map proc seq)))

  (define (remove element seq)
    (filter (lambda (x) (not (= x element)))
            seq))

  (define (permutations s)
    (if (null? s)                    ; empty set?
        (list '())                   ; sequence containing empty set
        (flatmap (lambda (x)
                   (map (lambda (p) (cons x p))
                        (permutations (remove x s))))
                 s)))
  (permutations '(3 1 2))
#+END_SRC

#+RESULTS: permutation
| 3 | 1 | 2 |
| 3 | 2 | 1 |
| 1 | 3 | 2 |
| 1 | 2 | 3 |
| 2 | 3 | 1 |
| 2 | 1 | 3 |

* Exercise 2.40

#+NAME: unique-pairs
#+BEGIN_SRC scheme :noweb yes
  <<sequence_procs>> ;; for enumerate-interval
  <<permutation>>  ;; for flatmap
  (define (unique-pairs n)
    (flatmap (lambda (j)
               (map (lambda (i) (list j i))
                    (enumerate-interval 1 (- j  1))))
             (enumerate-interval 1 n)))

  (unique-pairs 4)
#+END_SRC

We have ~(n choose 2)~ possible pairs
#+RESULTS: unique-pairs
| 2 | 1 |
| 3 | 1 |
| 3 | 2 |
| 4 | 1 |
| 4 | 2 |
| 4 | 3 |

* Exercise 2.41

#+BEGIN_SRC scheme :noweb yes
  <<sequence_procs>>
  <<permutation>>

  (define (unique-triples n)
    (flatmap (lambda (i)
               (flatmap (lambda (j)
                          (map (lambda (k) (list i j k))
                               (enumerate-interval 1 (- j 1))))
                (enumerate-interval 1 (- i 1))))
    (enumerate-interval 1 n)))

  (define (make-triple-sum triple)
    (list (car triple) (cadr triple) (caddr triple) (+ (car triple) (cadr triple) (caddr triple))))

  (define (sum-to-s triple s)
    (= (+ (car triple) (cadr triple) (caddr triple)) s))

  (define (triple-sum-to-s n s)
    (map make-triple-sum
         (filter (lambda (x) (sum-to-s x s))
                 (unique-triples n))))

  (triple-sum-to-s 7 12)
#+END_SRC

#+RESULTS:
| 5 | 4 | 3 | 12 |
| 6 | 4 | 2 | 12 |
| 6 | 5 | 1 | 12 |
| 7 | 3 | 2 | 12 |
| 7 | 4 | 1 | 12 |

* Exercise 2.42

Interesting! I remember solving on this problem on assembler back in my college days.

#+NAME: queens
#+BEGIN_SRC scheme :noweb yes
  <<sequence_procs>>
  <<permutation>>

  ;; Ended up spending 2 hours debugging my program because I was creating a list with an empty list:
  ;; (list '())
  ;; So far this is the biggest drawback I see to Lisp. Backtrace is very unhelpful
  (define empty-board '() )

  (define (adjoin-position row column rest)
    (cons (list row column) rest))

  (define (get-row queen)
    (car queen))

  (define (get-column queen)
    (cadr queen))

  (define (same-column? first_queen second_queen)
    (= (get-column first_queen) (get-column second_queen)))

  (define (same-row? first_queen second_queen)
    (= (get-row first_queen) (get-row second_queen)))

  (define (same-diagonal? first_queen second_queen)
    (or (= (+ (get-row first_queen) (get-column first_queen))
           (+ (get-row second_queen) (get-column second_queen)))
        (= (- (get-row first_queen) (get-column first_queen))
           (- (get-row second_queen) (get-column second_queen)))))


  (define (safe? column queens)
    ;; I probably can extract these 2 into methods...
    (let ((queen (car (filter (lambda (queen) (= (get-column queen) column)) queens)))
          (rest (filter (lambda (queen) (not (= (get-column queen) column))) queens)))
      (cond ((null? rest) #t)
            ;; Check if all the checks are False by using accumulate
            (else (not (accumulate (lambda (x y) (or x y)) #f 
                             (map (lambda (comp-queen) (or (same-column? queen comp-queen)
                                                           (same-row? queen comp-queen)
                                                           (same-diagonal? queen comp-queen)))
                                  rest)))))))

  (define (queens board-size)
    (define (queen-cols k)
      (if (= k 0)
          (list empty-board)
          (filter
           (lambda (positions) (safe? k positions))
           (flatmap
            (lambda (rest-of-queens)
              (map (lambda (new-row)
                     (adjoin-position new-row k rest-of-queens))
                   (enumerate-interval 1 board-size)))
            (queen-cols (- k 1))))))
    (queen-cols board-size))

  (queens 6)
#+END_SRC

#+RESULTS: queens
| (5 6) | (3 5) | (1 4) | (6 3) | (4 2) | (2 1) |
| (4 6) | (1 5) | (5 4) | (2 3) | (6 2) | (3 1) |
| (3 6) | (6 5) | (2 4) | (5 3) | (1 2) | (4 1) |
| (2 6) | (4 5) | (6 4) | (1 3) | (3 2) | (5 1) |

Result:
| (5 6) | (3 5) | (1 4) | (6 3) | (4 2) | (2 1) |
| (4 6) | (1 5) | (5 4) | (2 3) | (6 2) | (3 1) |
| (3 6) | (6 5) | (2 4) | (5 3) | (1 2) | (4 1) |
| (2 6) | (4 5) | (6 4) | (1 3) | (3 2) | (5 1) |

* Exercise 2.43
These are my current thoughts of this:
In the original proc we call flat map every time over a board 1 square smaller than the previous iteration. Being the size of the board n:

#+BEGIN_SRC
O(n*(n-1)*(n-2)...) = O(n!)
#+END_SRC


In the new proc, que call it over every flatmap iteration. If we had a board of size 2 we would have:

#+BEGIN_SRC
O(f(1)) = 1
O(f(2)) = 2*(2*O(1)) = O(2*(2*1))=O(2^2)
#+END_SRC

Size 3:

#+BEGIN_SRC
O(3*(3*(2*(2*1)))) = O(3^3*2^2) ~ O(3^3)
#+END_SRC

Finally, for a board of size n:

#+BEGIN_SRC
O(n*(n*((n-1)*(n-1)...) = O(n^n*(n-1)^(n-1)...)~ O(n^n)
#+END_SRC

* Exercise 2.44

#+BEGIN_SRC scheme
  (define (up-split painter n)
    (if (= n 0)
        painter
        (let ((smaller (up-split painter (- n 1))))
          (below painter (beside smaller smaller)))))
#+END_SRC

* Exercise 2.45
#+BEGIN_SRC scheme
  (define (split painter-pos smaller-pos)
    (lambda (painter n)
          (if (= n 0)
          painter
          (let ((smaller (split painter (- n 1))))
            (painter-pos painter (smaller-pos smaller smaller))))))

  (define right-split (split beside below))
  (define up-split (split below beside))
#+END_SRC

* Exercise 2.46
#+NAME: vectors
#+BEGIN_SRC scheme :results output
  (define (make-vect x y)
    (cons x y))

  (define (xcor-vect vect)
    (car vect))

  (define (ycor-vect vect)
    (cdr vect))
  (define (add-vect vect1 vect2)
    (make-vect (+ (xcor-vect vect1)
                  (xcor-vect vect2))
               (+ (ycor-vect vect1)
                  (ycor-vect vect2))))

  (define (sub-vect vect1 vect2)
    (make-vect (- (xcor-vect vect1)
                  (xcor-vect vect2))
               (- (ycor-vect vect1)
                  (ycor-vect vect2))))

  (define (scale-vect s vect)
    (make-vect (* s (xcor-vect vect))
               (* s (ycor-vect vect))))

  (define vector-1 (make-vect 2 7))
  (define vector-2 (make-vect 3 5))

  (display (add-vect vector-1 vector-2))
  (display "\n")
  (display (sub-vect vector-1 vector-2))
  (display "\n")
  (display (scale-vect 3 vector-1))
  (display "\n")

  (define (frame-coord-map frame)
    (lambda (v)
      (add-vect
       (origin-frame frame)
       (add-vect (scale-vect (xcor-vect v)
                             (edge1-frame frame))
                 (scale-vect (ycor-vect v)
                             (edge2-frame frame))))))

#+END_SRC

#+RESULTS:
: (5 . 12)
: (-1 . 2)
: (6 . 21)

* Exercise 2.47

Using ~list~:
#+BEGIN_SRC scheme :noweb yes
  <<vectors>>
  (define (make-frame origin edge1 edge2)
    (list origin edge1 edge2))

  (define (origin-frame frame)
    (car frame))

  (define (edge1-frame frame)
    (cadr frame))

  (define (edge2-frame frame)
    (caddr frame))
#+END_SRC

Using ~cons~:
#+BEGIN_SRC scheme :noweb yes
  <<vectors>>
  (define (make-frame origin edge1 edge2)
    (cons origin (cons edge1 edge2)))

  (define (origin-frame frame)
    (car frame))

  (define (edge1-frame frame)
    (cadr frame))

  (define (edge2-frame frame)
    (cddr frame))
#+END_SRC

* Exercise 2.48
#+BEGIN_SRC scheme :noweb yes
  <<vectors>>
  (define (make-segment start-vec end-vec)
    (cons start-vec end-vec))

  (define (start-segment segment)
    (car segment))

  (define (end-segment segment)
    (cdr segment))
#+END_SRC

* Exercise 2.49

#+BEGIN_SRC scheme
  (define (segments->painter segment-list)
    (lambda (frame)
      (for-each
       (lambda (segment)
         (draw-line
          ((frame-coord-map frame) (start-segment segment))
          ((frame-coord-map frame) (end-segment segment))))
       segment-list)))


  ;;a
  (define (paint-frame-outline frame)
    (let ((origin (origin-frame frame))
          (edge1 (edge1-frame frame))
          (edge2 (edge2-frame frame))
          ;; This transformation gives us the upper right point
          (edge3 ((frame-coord-map frame) (make-vect 1 1))))
      (segments->painter (list (make-segment origin edge1)
                               (make-segment origin edge2)
                               (make-segment edge2 edge3)
                               (make-segment edge1 edge3)))))

  ;;b
  (define (paint-frame-X frame)
    (let ((origin (origin-frame frame))
          (edge1 (edge1-frame frame))
          (edge2 (edge2-frame frame))
          ;; This transformation gives us the upper right point
          (edge3 ((frame-coord-map frame) (make-vect 1 1))))
      (segments->painter (list (make-segment origin edge3)
                               (make-segment edge1 edge2)))))


#+END_SRC

* Exercise 2.50
#+BEGIN_SRC scheme
  ;; Normal coordinate frame
  ;; ^e2
  ;; |
  ;; .-->e1
  ;; o


  ;; Flip hor
  ;;   ^e2
  ;;   |
  ;;<--.o
  ;;e1
  (define (flip-horiz painter)
    (transform-painter painter
                       (make-vect 1.0 0.0)   ; new `origin'
                       (make-vect 0.0 0.0)   ; new end of `edge1'
                       (make-vect 1.0 1.0))) ; new end of `edge2'

  ;; Flip 180 degrees
  ;; <--.o
  ;; e1 |
  ;;    v e2
  (define (flip-180 painter)
    (transform-painter painter
                       (make-vect 1.0 1.0)
                       (make-vect 0.0 1.0)
                       (make-vect 1.0 0.0)))

  ;; Flip 270 degrees
  ;;   ^e1
  ;;   |
  ;;<--.o
  ;;e2
  (define (flip-270 painter)
    (transform-painter painter
                       (make-vect 1.0 0.0)
                       (make-vect 1.0 1.0)
                       (make-vect 0.0 0.0)))
#+END_SRC

* Exercise 2.51

Implementing ~below~ in a similar way as ~beside~

#+BEGIN_SRC scheme
  (define (below painter1 painter2)
    (let ((split-point (make-vect 0.0 0.5)))
      (let ((paint-up
             (transform-painter painter1
                                split-point
                                (make-vect 1.0 0.5)
                                (make-vect 0.0 1.0)))
            (paint-down
             (transform-painter painter2
                                (make-vect 0.0 0.0)
                                (make-vect 1.0 0.0)
                                split-point)))
        (lambda (frame)
          (paint-up frame)
          (paint-down frame)))))
#+END_SRC

Implementing ~below~ using ~beside~ and flip operations.
#+BEGIN_SRC scheme
  (define (below painter1 painter2)
    (flip-90 (beside (flip-270 painter1)
                     (flip-270 painter2))))
#+END_SRC

* Exercise 2.53
#+BEGIN_SRC scheme
  (list 'a 'b 'c)
  (a b c)

  (list (list 'george))
  ((george))

  (cdr '((x1 x2) (y1 y2)))
  ((y1 y2))

  (cadr '((x1 x2) (y1 y2)))
  (y1 y2)

  (pair? (car '(a short list)))
  #f

  (memq 'red '((red shoes) (blue socks)))
  #f

  (memq 'red '(red shoes blue socks))
  (red shoes blue shocks)
#+END_SRC


* Exercise 2.54
#+BEGIN_SRC scheme :results output
  (define (equal? a b)
    (cond ((and (not (pair? a))
                (not (pair? b)))
           (eq? a b))
          ((and (pair? a)
                (pair? b))
           (and (equal? (car a) (car b))
                (equal? (cdr a) (cdr b))))
          (else #f)))

  (display (equal? '(this is a list) '(this is a list)))
  (display "\n")
  (display (equal? '(this is a list) '(this (is a) list)))
#+END_SRC

#+RESULTS:
: #t
: #f


* Exercise 2.55
The symbol ~'~ is equivalent to (quote).

So ~''abracadabra~ is the same as (quote (quote abracadabra)), which evaluates to ~(quote abracadabra)~

Therefore, ~(car ''abracadabra)~ will return ~quote~
And ~(cdr ''abracadabra)~ will return ~(abracadabra)~

* Differentiator
#+NAME: differentiator
#+BEGIN_SRC scheme
  (define (deriv exp var)
    (cond ((number? exp) 0)
          ((variable? exp)
           (if (same-variable? exp var) 1 0))
          ((sum? exp)
           (make-sum (deriv (addend exp) var)
                     (deriv (augend exp) var)))
          ((product? exp)
           (make-sum
            (make-product (multiplier exp)
                          (deriv (multiplicand exp) var))
            (make-product (deriv (multiplier exp) var)
                          (multiplicand exp))))
          (else
           (error "unknown expression type -- DERIV" exp))))

  (define (variable? x) (symbol? x))

  (define (same-variable? v1 v2)
    (and (variable? v1) (variable? v2) (eq? v1 v2)))

  (define (=number? exp num)
    (and (number? exp) (= exp num)))

  (define (make-sum a1 a2)
    (cond ((=number? a1 0) a2)
          ((=number? a2 0) a1)
          ((and (number? a1) (number? a2)) (+ a1 a2))
          (else (list '+ a1 a2))))


  (define (make-product m1 m2)
    (cond ((or (=number? m1 0) (=number? m2 0)) 0)
          ((=number? m1 1) m2)
          ((=number? m2 1) m1)
          ((and (number? m1) (number? m2)) (* m1 m2))
          (else (list '* m1 m2))))

  (define (sum? x)
    (and (pair? x) (eq? (car x) '+)))

  (define (addend s) (cadr s))
  (define (augend s) (caddr s))

  (define (product? x)
    (and (pair? x) (eq? (car x) '*)))

  (define (multiplier p) (cadr p))

  (define (multiplicand p) (caddr p))

  (deriv '(+ 2 2) 'x)
#+END_SRC

#+RESULTS: differentiator
: 0

* Exercise 2.56
The exercise in the Emacs info version seems to be wrong:

#+BEGIN_SRC 
n_1   n_2
--- = ---  if and only if n_1 d_2 = n_2 d_1
d_1   d_2
#+END_SRC

Compared to the book

#+BEGIN_SRC 
d(u^n)              du
------ = n*u^(n-1) ----
  dx                dx
#+END_SRC

Let's tackle the second one

#+BEGIN_SRC scheme :noweb yes :results value verbatim
  <<differentiator>>
  (define (deriv exp var)
    (cond ((number? exp) 0)
          ((variable? exp)
           (if (same-variable? exp var) 1 0))
          ((sum? exp)
           (make-sum (deriv (addend exp) var)
                     (deriv (augend exp) var)))
          ((product? exp)
           (make-sum
            (make-product (multiplier exp)
                          (deriv (multiplicand exp) var))
            (make-product (deriv (multiplier exp) var)
                          (multiplicand exp))))
          ((exponentiation? exp)
           (make-product (make-product (exponent exp)
                                       (make-exponentiation (base exp)
                                                            (- (exponent exp) 1)))
                         (deriv (base exp) var)))
          (else
           (error "unknown expression type -- DERIV" exp))))

  (define (make-exponentiation base exponent)
    (cond ((=number? exponent 1) base)
          ((=number? exponent 0) 1)
          ((=number? base 0) 0)
          ((and (number? base) (number? exponent)) (expt base exponent))
          (else (list '** base exponent))))

  (define (exponentiation? x)
    (and (pair? x) (eq? (car x) '**)))

  (define (base x)
    (cadr x))

  (define (exponent x)
    (caddr x))

  (deriv '(** x 2) 'x)
#+END_SRC

#+RESULTS:
: (+ (* x y) (* y x))

* Exercise 2.57

I was stuck on this exercise. Tryint to modify augend and make-sum using dotted-tail notation.

Turns out it's straightforward if we use our old friend ~accumulate~ [[http://community.schemewiki.org/?sicp-ex-2.57][(ref)]] And conceptually it makes sense, we are making a sum over all the items in the expression's  augend.

#+BEGIN_SRC scheme :noweb yes :results value verbatim
  <<differentiator>>
  <<sequence_procs>> ;; for accumulate
  (define (augend s)    
    (accumulate make-sum 0 (cddr s))) 

  (define (multiplicand p)
    (accumulate make-product 1 (cddr p)))

  (deriv '(* x y (+ x 3)) 'x)
#+END_SRC

#+RESULTS:
: (+ (* x y) (* y (+ x 3)))

* Exercise 2.58

Using infix notation, instead of prefix. If we keep all the parenthesis it's easy, as it's almos the same as the prefix case, just moving the symbol position from the first to the second place in the list.

#+BEGIN_SRC scheme :noweb yes :results value verbatim
  <<differentiator>>
  (define (make-sum a1 a2)
    (cond ((=number? a1 0) a2)
          ((=number? a2 0) a1)
          ((and (number? a1) (number? a2)) (+ a1 a2))
          (else (list a1 '+ a2))))


  (define (make-product m1 m2)
    (cond ((or (=number? m1 0) (=number? m2 0)) 0)
          ((=number? m1 1) m2)
          ((=number? m2 1) m1)
          ((and (number? m1) (number? m2)) (* m1 m2))
          (else (list m1 '* m2))))

  (define (sum? x)
    (and (pair? x) (eq? (cadr x) '+)))

  (define (addend s) (car s))
  (define (augend s) (caddr s))

  (define (product? x)
    (and (pair? x) (eq? (cadr x) '*)))

  (define (multiplier p) (car p))
  (define (multiplicand p) (caddr p))

  (deriv '(x + (3 * (x + (y + 2)))) 'x)
#+END_SRC

#+RESULTS:
: 4

* Exercise 2.59


#+BEGIN_SRC scheme
  (define (element-of-set? x set)
    (cond ((null? set) #f)
          ((equal? x (car set)) #t)
          (else (element-of-set? x (cdr set)))))


  (define (adjoin-set x set)
    (if (element-of-set? x set)
        set
        (cons x set)))

  (define (intersection-set set1 set2)
    (cond ((or (null? set1) (null? set2)) '())
          ((element-of-set? (car set1) set2)
           (cons (car set1)
                 (intersection-set (cdr set1) set2)))
          (else (intersection-set (cdr set1) set2))))

  (define (union-set set1 set2)
    (cond ((null? set2) set1)
          ((element-of-set? (car set2) set1)
           (union-set (cdr set2) set1))
          (else (cons (car set2) (union-set (cdr set2) set1)))))

  ;; Theta(n^2). We run element-of-set? on every element of set2
  (union-set (list 1 7 10) (list 3 4 1 8 2 7 5))
#+END_SRC

#+RESULTS:
| 3 | 4 | 1 | 10 | 8 | 2 | 7 | 5 |

* Exercise 2.60
#+BEGIN_SRC scheme :results output
  ;; allow for duplicates (list 2 3 2 1 3 2 2)
  ;; element-of-set? adjoin-set union-set intersection-set

  (define (element-of-set? x set)
    (cond ((null? set) #f)
          ((equal? x (car set)) #t)
          (else (element-of-set? x (cdr set)))))

  (define (adjoin-set x set)
    (cons x set))

   (define (intersection-set set1 set2)
    (cond ((or (null? set1) (null? set2)) '())
          ((element-of-set? (car set1) set2)
           (cons (car set1)
                 (intersection-set (cdr set1) set2)))
          (else (intersection-set (cdr set1) set2))))

    (define (union-set set1 set2)
      (cond ((null? set2) set1)
            ((element-of-set? (car set2) set1)
             (union-set (cdr set2) set1))
            (else (cons (car set2) (union-set (cdr set2) set1)))))

  (display (element-of-set? 2 (list 2 3 2 1 3 2 2)))
  (display "\n")
  (display (adjoin-set 2 (list 2 3 2 1 3 2 2)))
  (display "\n")
  (display (intersection-set (list 4 4 1 2 1 5)
                             (list 2 3 2 1 3 2 2)))
  (display "\n")
  (display (union-set (list 4 4 7 2 1 5)
                      (list 2 3 2 1 3 2 2)))
#+END_SRC

#+RESULTS:
: #t
: (2 2 3 2 1 3 2 2)
: (1 2 1)
: (4 3 4 7 3 1 2 5 2)

The only procedure that needs to be modified is ~adjoin-set~. We can make this a constant time operation as we don't need to check whether the element belongs to the set already, which is a ~Theta(n)~ operation.
We pay for this in the procedures ~union-set~ and ~intersection-set~. These are still ~Theta(n^2)~, but now n grows with the number of elements of the set (not unique elements).
This representation in an application that uses mainly adds new elements to a set and checks if they belong, as we trade a constant adjoin for a slightly increase in the linear time ~element-of-set?~.
If we need to perform union and intersection operations frequently, the original representation would give us better performance.

* Exercise 2.61

Now we consider the sets as ordered lists.

Similarly to the case with ~element-of-set?~, in this implementation ~adjoin-set~ is also ~Theta(n/2)~. The number of steps is at most ~Theta(n)~, when the number we want to adjoin is largest than every number in the set. The procedure finishes as soon as it finds a number in the set equal or less than the adjoining number.

#+NAME: ordered
#+BEGIN_SRC scheme :results output

  (define (element-of-set? x set)
    (cond ((null? set) #f)
          ((= x (car set)) #t)
          ((< x (car set)) #f)
          (else (element-of-set? x (cdr set)))))

  (define (intersection-set set1 set2)
    (if (or (null? set1) (null? set2))
        '()
        (let ((x1 (car set1)) (x2 (car set2)))
          (cond ((= x1 x2)
                 (cons x1
                       (intersection-set (cdr set1)
                                         (cdr set2))))
                ((< x1 x2)
                 (intersection-set (cdr set1) set2))
                ((< x2 x1)
                 (intersection-set set1 (cdr set2)))))))

  (define (adjoin-set x set)
    (cond ((null? set) (list x))
          ((= x (car set)) set)
          ((< x (car set)) (cons x set))
          (else (cons (car set) (adjoin-set x (cdr set))))))

  (display (adjoin-set 7 (list 1 2 4 9)))
  (display "\n")
  (display (adjoin-set 11 (list 1 2 4 9)))
  (display "\n")
  (display (adjoin-set -1 (list 1 2 4 9)))
  (display "\n")
  (display (adjoin-set 2 (list 1 2 4 9)))
  (display "\n")
#+END_SRC

#+RESULTS:
: (1 2 4 7 9)
: (1 2 4 9 11)
: (-1 1 2 4 9)
: (1 2 4 9)

* Exercise 2.62

#+BEGIN_SRC scheme :noweb yes :results output
  <<ordered>>
  ;; (1 2 4 5) (2 5 7 8 9)
  ;; (4 5) (2 5 7 8 9)
  (define (union-set set1 set2)
    (cond ((null? set1) set2)
          ((null? set2) set1)
          (else (let ((x1 (car set1)) (x2 (car set2)))
                  (cond ((< x1 x2)
                         (cons x1 (union-set (cdr set1) set2)))
                        ((> x1 x2)
                         (cons x2 (union-set set1 (cdr set2))))
                        (else (cons x1 (union-set (cdr set1) (cdr set2)))))))))

  (display (union-set (list 1 2 4 5) (list 2 5 7 8 9)))
  (display "\n")
  (display (union-set (list 4 5) (list 2 5 7 8 9)))
  (display "\n")
  (display (union-set (list 1 7 10) (list 1 2 3 4 5 7 8)))
#+END_SRC

#+RESULTS:
: (1 2 4 7 9)
: (1 2 4 9 11)
: (-1 1 2 4 9)
: (1 2 4 9)
: (1 2 4 5 7 8 9)
: (2 4 5 7 8 9)
: (1 2 3 4 5 7 8 10)


* Exercise 2.63

- a) Both procedures perform an in-order trasversal of the tree, and produce the ordered list of the nodes. i.e: (1 3 5 7 9 11)
- b) TODO

* Exercise 2.64
- a)
The tree produced by ~(1 3 5 7 9 11)~ will look like:
#+BEGIN_SRC 
      5
    /   \
   1     9
    \   / \
     3 7  11
#+END_SRC
The ~partial-tree~ procedure works the following way.
First, we define the left side of the tree to be ~floor( (n-1) / 2)~ and calculate this partial tree. We den set the current node to be the car of the remaining elements, and the right tree elemetns to be the cdr of the remaining elements. We calculate the right partial tree.
Finally, we cons the constructed tree (node, left-tree, right-tree), and the remaining elements, which is passed up the stack.

- b) 
#+BEGIN_SRC 
T(n) = T(n/2) + T(n/2) + O(1)
T(n) = O(n)
#+END_SRC
Where the two ~T(n/2)~ come from the right and left ~partial-tree~ construction, and ~O(1)~ from the ~cons~ construction of the final tree.



* Exercise 2.65
~union-set~ and ~intersection-set~ from exercises 2.61 and 2.62 are ~O(n)~, but work on ordered lists.

We have just seen two methods for convertin from ordered list to binary tree, and viceversa, in ~O(n)~ time.

We just need to make these conversion before applying our ~O(n)~ solutions on ordered lists (and afterwards to return the right type).

* Exercise 2.66
#+BEGIN_SRC scheme
  (define (lookup given-key set-of-records)
    (cond ((null? set-of-records) false)
          ((= given-key (key (entry set-of-records)))
           (entry set-of-records))
          ((< given-key (key (entry set-of-records)))
           (lookup given-key (left-branch set-of-records)))
          ((> given-key (key (entry set-of-records)))
           (lookup given-key (right-branch set-of-records)))))
#+END_SRC

* Exercise 2.67

#+NAME: huffman_procs
#+BEGIN_SRC scheme
  (define (make-leaf symbol weight)
    (list 'leaf symbol weight))

  (define (leaf? object)
    (eq? (car object) 'leaf))

  (define (symbol-leaf x) (cadr x))

  (define (weight-leaf x) (caddr x))

  (define (make-code-tree left right)
    (list left
          right
          (append (symbols left) (symbols right))
          (+ (weight left) (weight right))))

  (define (left-branch tree) (car tree))

  (define (right-branch tree) (cadr tree))

  (define (symbols tree)
    (if (leaf? tree)
        (list (symbol-leaf tree))
        (caddr tree)))

  (define (weight tree)
    (if (leaf? tree)
        (weight-leaf tree)
        (cadddr tree)))

  (define (decode bits tree)
    (define (decode-1 bits current-branch)
      (if (null? bits)
          '()
          (let ((next-branch
                 (choose-branch (car bits) current-branch)))
            (if (leaf? next-branch)
                (cons (symbol-leaf next-branch)
                      (decode-1 (cdr bits) tree))
                (decode-1 (cdr bits) next-branch)))))
    (decode-1 bits tree))

  (define (choose-branch bit branch)
    (cond ((= bit 0) (left-branch branch))
          ((= bit 1) (right-branch branch))
          (else (error "bad bit -- CHOOSE-BRANCH" bit))))

  (define (make-leaf-set pairs)
    (if (null? pairs)
        '()
        (let ((pair (car pairs)))
          (adjoin-set (make-leaf (car pair)    ; symbol
                                 (cadr pair))  ; frequency
                      (make-leaf-set (cdr pairs))))))

  (define (adjoin-set x set)
    (cond ((null? set) (list x))
          ((< (weight x) (weight (car set))) (cons x set))
          (else (cons (car set)
                      (adjoin-set x (cdr set))))))
#+END_SRC


* Exercise 2.67
#+BEGIN_SRC scheme :noweb yes
  <<huffman_procs>>

  (define sample-tree
    (make-code-tree (make-leaf 'A 4)
                    (make-code-tree
                     (make-leaf 'B 2)
                     (make-code-tree (make-leaf 'D 1)
                                     (make-leaf 'C 1)))))

  (define sample-message '(0 1 1 0 0 1 0 1 0 1 1 1 0))


  (decode sample-message sample-tree)
#+END_SRC

#+RESULTS:
| A | D | A | B | B | C | A |

* Exercise 2.68
#+NAME: encode
#+BEGIN_SRC scheme :noweb yes
  <<huffman_procs>>

  (define (element-of-set? x set)
    (cond ((null? set) #f)
          ((eq? x (car set)) #t)
          (else (element-of-set? x (cdr set)))))

  (define (encode-symbol symbol tree)
    (cond ((leaf? tree)
           '())
           ((element-of-set? symbol (symbols (left-branch tree)))
            (cons 0 (encode-symbol symbol (left-branch tree))))
           ((element-of-set? symbol (symbols (right-branch tree)))
            (cons 1 (encode-symbol symbol (right-branch tree))))))


  (define (encode message tree)
    (if (null? message)
        '()
        (append (encode-symbol (car message) tree)
                (encode (cdr message) tree))))


  (define sample-tree
    (make-code-tree (make-leaf 'A 4)
                    (make-code-tree
                     (make-leaf 'B 2)
                     (make-code-tree (make-leaf 'D 1)
                                     (make-leaf 'C 1)))))

  (define sample-message '(A D A B B C A))

  (encode sample-message sample-tree)

#+END_SRC

#+RESULTS:
| 0 | 1 | 1 | 0 | 0 | 1 | 0 | 1 | 0 | 1 | 1 | 1 | 0 |

The encoded message matches what we decoded in Exercise 2.67

* Exercise 2.69
#+NAME: generate_huffman
#+BEGIN_SRC scheme :noweb yes :results value verbatim
    <<huffman_procs>>
    <<encode>>
    (define (generate-huffman-tree pairs)
      (successive-merge (make-leaf-set pairs)))

    (define (successive-merge leaf-set)
      (if (equal? (length leaf-set) 1)
          (car leaf-set)
          (let ((left (car leaf-set))
                (right (cadr leaf-set)))
            (let ((new-tree (make-code-tree left right)))
              (successive-merge (adjoin-set new-tree (cddr leaf-set)))))))

  ;;Encode the sample string in SCIP
  ;;BACADAEAFABBAAAGAH
  (define pairs '((A 8) (B 3) (C 1) (D 1) (E 1) (F 1) (G 1) (H 1)))
  (define test-tree (generate-huffman-tree pairs))
  ;;Make sure it's 42 bits
  (length (encode '(B A C A D A E A F A B B A A A G A H) test-tree) )
#+END_SRC

#+RESULTS:
: 42

* Exercise 2.70

#+BEGIN_SRC scheme :noweb yes :results values verbatim
  <<huffman_procs>>
  <<encode>>
  <<generate_huffman>>
  (define pairs '((A 2) (NA 16) (BOOM 1) (SHA 3) (GET 2) (YIP 9) (JOB 2) (WAH 1)))
  (define message '(GET A JOB SHA NA NA NA NA NA NA NA NA GET A JOB SHA NA NA NA NA NA NA NA NA WAH YIP YIP YIP YIP YIP YIP YIP YIP YIP SHA BOOM))
  (define code-tree (generate-huffman-tree pairs))

  (length (encode message code-tree))
#+END_SRC

#+RESULTS:
: 84

The message is 84 bits long when encoded with a Huffman code.

If we were to encode it with a fixed-length code, we have 8 different symbols, so 3 bits per symbol.

The message consists of 36 words, so the message would be 3x36=102 bits long.


* Exercise 2.71
Let's see how the tree looks with n=5

#+BEGIN_SRC 
            {a b c d e} 31
              /      \
            e 16   {a b c d} 15
                     /   \
                   d 8  {a b c} 7
                         /  \
                       c 4 {a b} 3
                           /  \
                         a 1  b 2
#+END_SRC

All trees with same symbol frequency will have the same shape. The minimum number of bits we need to represent a symbol is 1, and the maximum, n-1

* Exercise 2.72
A worst case scenario for the order of growth can be calculated using exercise 2.71.

In that case, for the least frequent symbol the order of growth of the number of steps needed to encode it will be:

#+BEGIN_SRC 
O(n*(n-1)) = O(n^2)
#+END_SRC

For the minimum number of steps, we only need to iterate through the list once: ~O(n)~

* Exercise 2.73 

These results are not tested, as we don't have the ~put~ and ~get~ procedures yet (this will come in section 3).

a) ~number?~ and ~same-variable?~ are predicates applied to untagged, single elements (numbers or variables).

b)
#+BEGIN_SRC scheme
  (define (install-symbolic-derivation-package)
    (define (deriv-sum exp var)
      (make-sum (deriv (addend exp) var)
                (deriv (augend exp) var)))
    (put 'deriv '+ deriv-sum)

    (define (deriv-product exp var)
      (make-sum
       (make-product (multiplier exp)
                     (deriv (multiplicand exp) var))
       (make-product (deriv (multiplier exp) var)
                     (multiplicand exp))))
    (put 'deriv '* deriv-product))

  (define (deriv exp var)
    (cond ((number? exp) 0)
          ((variable? exp) (if (same-variable? exp var) 1 0))
          (else ((get 'deriv (operator exp)) (operands exp)
                 var))))

  (define (operator exp) (car exp))

  (define (operands exp) (cdr exp))
#+END_SRC

d) In this case we would have to swap the operands in our ~put~ operation. We could interpret it, in this case, as having a different set of operations for each arithmetic operator. For example we can install a derivation operation, simplification, etc.

#+BEGIN_SRC scheme
  (define (install-symbolic-derivation-package)
    (define (deriv-sum exp var)
      (make-sum (deriv (addend exp) var)
                (deriv (augend exp) var)))
    (put '+ 'deriv deriv-sum)

    (define (deriv-product exp var)
      (make-sum
       (make-product (multiplier exp)
                     (deriv (multiplicand exp) var))
       (make-product (deriv (multiplier exp) var)
                     (multiplicand exp))))
    (put '* 'deriv deriv-product))

  (define (deriv exp var)
    (cond ((number? exp) 0)
          ((variable? exp) (if (same-variable? exp var) 1 0))
          (else ((get 'deriv (operator exp)) (operands exp)
                 var))))

  (define (operator exp) (car exp))

  (define (operands exp) (cdr exp))
#+END_SRC

* Exercise 2.74

We can index the operations by division, implementing a different method suited for the particular implementations

                
| Operations | Division1            | Division2            |
|------------+----------------------+----------------------|
| get-record | get-record-division1 | get-record-division2 |
| get-salary | get-salary-division1 | get-salary-division2 |
| ...        |                      |                      |

a)

#+BEGIN_SRC scheme
  (define (get-record division employee-name)
    ((get 'get-record division) employee-name)
#+END_SRC

b)
#+BEGIN_SRC scheme
  (define (get-salary division employee-record)
    ((get 'get-salary division) employee-record))
#+END_SRC

* Exercise 2.75
#+BEGIN_SRC scheme 
  ;; Needed to have `assert` in Guile
  (import (rnrs (6)))

  (define (make-from-mag-ang mag ang)
    (define (dispatch op)
      (cond ((eq? op 'magnitude) mag)
            ((eq? op 'angle) ang)
            ((eq? op 'real-part)
             (* mag (cos ang)))
            ((eq? op 'imag-part)
             (* mag (sin ang)))))
    dispatch)

  (define (apply-generic op arg) (arg op))
  (define (real-part z) (apply-generic 'real-part z))
  (define (imag-part z) (apply-generic 'imag-part z))
  (define (magnitude z) (apply-generic 'magnitude z))
  (define (angle z) (apply-generic 'angle z))


  (define z (make-from-mag-ang 1 0))
  (assert (equal? (real-part z) 1))
  (assert (equal? (imag-part z) 0))
  (assert (equal? (magnitude z) 1))
  (assert (equal? (angle z) 0))
#+END_SRC

#+RESULTS:
: #t

* Exercise 2.76

** Which changes must be made to a system in order to add new types or new operations?

*** Generic operations with explicit dispatch

Adding a new type is easy. We need to create the constructor and attach the appropiate tag and modify the existing operations to include it.
But adding a new operation means defining a new procedure, existing code doesnt need to be updated.

*** Data-directed style
Here, to add a new operation we just need to add it to the table in the installation procedure.
Adding a new type would require defining an installation procedure where all the operations for this type are added to the symbol table.
If we dont use the installation procedure defined in the book, both can be done without modifying existing code, as we only need to add a row or column to the symbol table.
*** Message-passing style
In message passing style all the operations are defined in the constructor for each type. Adding a new operation means adding it to all constructors.
Adding a new type is done by defining a new procedure, without the need of modifying existing code.

** Which organizations would be most appropriate for a system in which new types must often be added?
Message-passing or data-directed

** Which would be most appropriate for a system in which new operations must often be added?
Generic operations with explicit dispatch, or data-directed

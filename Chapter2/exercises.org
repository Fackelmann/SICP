#+PROPERTY: header-args    :exports both
This is an org-mode file with ~scheme~ code blocks. If you clone this repo you can execute each block inside this file with ~C-c C-c~.

Because of some mysterious reason, results don't show up in the rendered github file. You can see them by opening the raw file.

* Table of Contents :TOC:
- [[#common][Common]]
- [[#exercise-21][Exercise 2.1]]
- [[#exercise-22][Exercise 2.2]]
- [[#exercise-23][Exercise 2.3]]
- [[#exercise-24][Exercise 2.4]]
- [[#exercise-25][Exercise 2.5]]

* Common

Defining commong functions here, so we don't need to repeat them over all the code blocks. 
#+NAME: common_block
#+BEGIN_SRC scheme
  (define (square x)
    (* x x))

  (define (gcd a b)
    (if (= b 0)
        a
        (gcd b (remainder a b))))

  (define (power x n)
    (if (= n 0)
        1
        (* x (power x (- n 1)))))
#+END_SRC


* Exercise 2.1
#+BEGIN_SRC scheme :noweb yes :results output
  <<common_block>>
  (define (numer x) (car x))

  (define (denom x) (cdr x))

  (define (print-rat x)
    (display "\n")
    (display (numer x))
    (display "/")
    (display (denom x)))

  (define (make-rat n d)
    (define (is-positive? n d)
      (cond ((and (> n 0) (< d 0))
             -1)
            ((and (< n 0) (> d 0))
             -1)
            (else
             1)))
    (let ((g (gcd n d))
          (sign (is-positive? n d)))
      (cons (* sign (/ n g)) (* sign (/ d g)))))

  (print-rat (make-rat 3 -6))
  (print-rat (make-rat -3 6))
  (print-rat (make-rat -3 -6))
  (print-rat (make-rat 3 6))

#+END_SRC

#+RESULTS:
: 
: -1/2
: -1/2
: 1/2
: 1/2

* Exercise 2.2

#+NAME: ex_2.2
#+BEGIN_SRC scheme :results output
  (define (make-segment start end)
    (cons start end))

  (define (start-segment segment)
    (car segment))

  (define (end-segment segment)
    (cdr segment))

  (define (make-point x y)
    (cons x y))

  (define (x-point point)
    (car point))

  (define (y-point point)
    (cdr point))

  (define (print-point p)
    (display "\n")
    (display "(")
    (display (x-point p))
    (display ",")
    (display (y-point p))
    (display ")"))

  (define (midpoint-segment segment)
    (let ((start (start-segment segment))
          (end (end-segment segment)))
      (let ((midx (/ (+ (x-point start)
                        (x-point end))
                     2))
            (midy (/ (+ (y-point start)
                        (y-point end))
                     2)))
        (make-point midx midy))))

  (define my-segment (make-segment (make-point 1 1)
                                   (make-point 2 2)))

  (define midpoint (midpoint-segment my-segment))

;;  (print-point midpoint)
#+END_SRC

#+RESULTS:
: 
: (3/2,3/2)

* Exercise 2.3

#+BEGIN_SRC scheme :noweb yes :results output
  <<ex_2.2>>
  ;; Implement rectangles with sides parallel to the axis for now
  ;; Generalizing it adds complexity without addin much value (IMO) to this exercise
  (define (rectangle lower_left upper_right)
    (cons lower_left upper_right))

  (define (rect-ll rectangle)
    (car rectangle))

  (define (rect-ur rectangle)
    (cdr rectangle))

  (define (rect-perimeter rectangle)
    (* (+ (- (x-point (rect-ur rectangle))
             (x-point (rect-ll rectangle)))
          (- (y-point (rect-ur rectangle))
             (y-point (rect-ll rectangle))))
       2))

  (define (rect-area rectangle)
    (* (- (x-point (rect-ur rectangle))
          (x-point (rect-ll rectangle)))
       (- (y-point (rect-ur rectangle))
          (y-point (rect-ll rectangle)))))

  (define my-rectangle (rectangle (make-point 1 0)
                                  (make-point 10 2)))

  (display "\n")
  (display (rect-perimeter my-rectangle))
  (display "\n")
  (display (rect-area my-rectangle))
#+END_SRC

#+RESULTS:
: 
: 22
: 18

* Exercise 2.4
Check that it works as expected:
#+BEGIN_SRC scheme
(car (cons 3 2))
(car (lambda (m) (m 3 2)))
((lambda (p q) p) 3 2)
3
#+END_SRC

And ~cdr~ implementation:
#+BEGIN_SRC scheme
  (define (cdr z)
    (z (lambda (p q) q)))
#+END_SRC

* Exercise 2.5

#+BEGIN_SRC scheme :noweb yes :results output
  <<common_block>>
  (define (cons a b)
    (* (power 2 a)
       (power 3 b)))

  (define (max-exponent n a)
    (if (= 0 (remainder n a))
        (+ 1 (max-exponent (/ n a)  a))
        0))

  (define (car z)
    (max-exponent z 2))

  (define (cdr z)
    (max-exponent z 3))

  ;; Test
  ;; It seems that Guile doesn't suppor assert
  ;; strange
  ;; (let ((list (cons 5 7)))
  ;;   (assert (= (car list) 5))
  ;;   (assert (= (cdr list) 7)))

  ;; Test

  (let ((list (cons 5 7)))
    (display "\n")
    (display (= (car list) 5))
    (display "\n")
    (display (= (cdr list) 7)))

  (let ((list (cons 127 1)))
    (display "\n")
    (display (= (car list) 127))
    (display "\n")
    (display (= (cdr list) 1)))

  (let ((list (cons 21 32)))
    (display "\n")
    (display (= (car list) 21))
    (display "\n")
    (display (= (cdr list) 32)))
#+END_SRC

#+RESULTS:
: 
: #t
: #t
: #t
: #t
: #t
: #t

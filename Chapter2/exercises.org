#+PROPERTY: header-args    :exports both
This is an org-mode file with ~scheme~ code blocks. If you clone this repo you can execute each block inside this file with ~C-c C-c~.

Because of some mysterious reason, results don't show up in the rendered github file. You can see them by opening the raw file.

* Table of Contents :TOC:
- [[#common][Common]]
- [[#exercise-21][Exercise 2.1]]
- [[#exercise-22][Exercise 2.2]]
- [[#exercise-23][Exercise 2.3]]
- [[#exercise-24][Exercise 2.4]]
- [[#exercise-25][Exercise 2.5]]
- [[#exercise-26][Exercise 2.6]]
- [[#exercise-27][Exercise 2.7]]
- [[#exercise-28][Exercise 2.8]]
- [[#exercise-29][Exercise 2.9]]
- [[#exercise-210][Exercise 2.10]]
- [[#exercise-211][Exercise 2.11]]
- [[#exercise-212][Exercise 2.12]]
- [[#exercise-217][Exercise 2.17]]
- [[#exercise-218][Exercise 2.18]]
- [[#exercise-219][Exercise 2.19]]
- [[#exercise-220][Exercise 2.20]]
- [[#exercise-221][Exercise 2.21]]
- [[#exercise-222][Exercise 2.22]]
- [[#exercise-223][Exercise 2.23]]
- [[#exercise-224][Exercise 2.24]]
- [[#exercise-225][Exercise 2.25]]
- [[#exercise-226][Exercise 2.26]]
- [[#exercise-227][Exercise 2.27]]
- [[#exercise-228][Exercise 2.28]]
- [[#exercise-229][Exercise 2.29]]
- [[#exercise-230][Exercise 2.30]]
- [[#exercise-231][Exercise 2.31]]
- [[#exercise-232][Exercise 2.32]]
- [[#exercise-233][Exercise 2.33]]
- [[#exercise-234][Exercise 2.34]]
- [[#exercise-235][Exercise 2.35]]
- [[#exercise-236][Exercise 2.36]]
- [[#exercise-237][Exercise 2.37]]
- [[#exercise-238][Exercise 2.38]]
- [[#exercise-239][Exercise 2.39]]
- [[#exercise-240][Exercise 2.40]]
- [[#exercise-241][Exercise 2.41]]
- [[#exercise-242][Exercise 2.42]]
- [[#exercise-243][Exercise 2.43]]
- [[#exercise-244][Exercise 2.44]]
- [[#exercise-245][Exercise 2.45]]

* Common

Defining common functions here, so we don't need to repeat them over all the code blocks. 
#+NAME: common_block
#+BEGIN_SRC scheme
  (define (square x)
    (* x x))

  (define (gcd a b)
    (if (= b 0)
        a
        (gcd b (remainder a b))))

  (define (power x n)
    (if (= n 0)
        1
        (* x (power x (- n 1)))))
#+END_SRC


* Exercise 2.1
#+BEGIN_SRC scheme :noweb yes :results output
  <<common_block>>
  (define (numer x) (car x))

  (define (denom x) (cdr x))

  (define (print-rat x)
    (display "\n")
    (display (numer x))
    (display "/")
    (display (denom x)))

  (define (make-rat n d)
    (define (is-positive? n d)
      (cond ((and (> n 0) (< d 0))
             -1)
            ((and (< n 0) (> d 0))
             -1)
            (else
             1)))
    (let ((g (gcd n d))
          (sign (is-positive? n d)))
      (cons (* sign (/ n g)) (* sign (/ d g)))))

  (print-rat (make-rat 3 -6))
  (print-rat (make-rat -3 6))
  (print-rat (make-rat -3 -6))
  (print-rat (make-rat 3 6))

#+END_SRC

#+RESULTS:
: 
: -1/2
: -1/2
: 1/2
: 1/2

* Exercise 2.2

#+NAME: ex_2.2
#+BEGIN_SRC scheme :results output
  (define (make-segment start end)
    (cons start end))

  (define (start-segment segment)
    (car segment))

  (define (end-segment segment)
    (cdr segment))

  (define (make-point x y)
    (cons x y))

  (define (x-point point)
    (car point))

  (define (y-point point)
    (cdr point))

  (define (print-point p)
    (display "\n")
    (display "(")
    (display (x-point p))
    (display ",")
    (display (y-point p))
    (display ")"))

  (define (midpoint-segment segment)
    (let ((start (start-segment segment))
          (end (end-segment segment)))
      (let ((midx (/ (+ (x-point start)
                        (x-point end))
                     2))
            (midy (/ (+ (y-point start)
                        (y-point end))
                     2)))
        (make-point midx midy))))

  (define my-segment (make-segment (make-point 1 1)
                                   (make-point 2 2)))

  (define midpoint (midpoint-segment my-segment))

;;  (print-point midpoint)
#+END_SRC

#+RESULTS:
: 
: (3/2,3/2)

* Exercise 2.3

#+BEGIN_SRC scheme :noweb yes :results output
  <<ex_2.2>>
  ;; Implement rectangles with sides parallel to the axis for now
  ;; Generalizing it adds complexity without addin much value (IMO) to this exercise
  (define (rectangle lower_left upper_right)
    (cons lower_left upper_right))

  (define (rect-ll rectangle)
    (car rectangle))

  (define (rect-ur rectangle)
    (cdr rectangle))

  (define (rect-perimeter rectangle)
    (* (+ (- (x-point (rect-ur rectangle))
             (x-point (rect-ll rectangle)))
          (- (y-point (rect-ur rectangle))
             (y-point (rect-ll rectangle))))
       2))

  (define (rect-area rectangle)
    (* (- (x-point (rect-ur rectangle))
          (x-point (rect-ll rectangle)))
       (- (y-point (rect-ur rectangle))
          (y-point (rect-ll rectangle)))))

  (define my-rectangle (rectangle (make-point 1 0)
                                  (make-point 10 2)))

  (display "\n")
  (display (rect-perimeter my-rectangle))
  (display "\n")
  (display (rect-area my-rectangle))
#+END_SRC

#+RESULTS:
: 
: 22
: 18

* Exercise 2.4
Check that it works as expected:
#+BEGIN_SRC scheme
(car (cons 3 2))
(car (lambda (m) (m 3 2)))
((lambda (p q) p) 3 2)
3
#+END_SRC

And ~cdr~ implementation:
#+BEGIN_SRC scheme
  (define (cdr z)
    (z (lambda (p q) q)))
#+END_SRC

* Exercise 2.5

#+BEGIN_SRC scheme :noweb yes :results output
  <<common_block>>
  (define (cons a b)
    (* (power 2 a)
       (power 3 b)))

  (define (max-exponent n a)
    (if (= 0 (remainder n a))
        (+ 1 (max-exponent (/ n a)  a))
        0))

  (define (car z)
    (max-exponent z 2))

  (define (cdr z)
    (max-exponent z 3))

  ;; Test
  ;; It seems that Guile doesn't suppor assert
  ;; strange
  ;; (let ((list (cons 5 7)))
  ;;   (assert (= (car list) 5))
  ;;   (assert (= (cdr list) 7)))

  ;; Test

  (let ((list (cons 5 7)))
    (display "\n")
    (display (= (car list) 5))
    (display "\n")
    (display (= (cdr list) 7)))

  (let ((list (cons 127 1)))
    (display "\n")
    (display (= (car list) 127))
    (display "\n")
    (display (= (cdr list) 1)))

  (let ((list (cons 21 32)))
    (display "\n")
    (display (= (car list) 21))
    (display "\n")
    (display (= (cdr list) 32)))
#+END_SRC

#+RESULTS:
: 
: #t
: #t
: #t
: #t
: #t
: #t

* Exercise 2.6

Let's start by evaluating ~(add-1 zero)~
#+BEGIN_SRC scheme
(add-1 zero)
(lambda (f) (lambda (x) (f ((zero f) x))))
#+END_SRC

And evaluating ~(zero f)~

#+BEGIN_SRC scheme
(zero f)
(lambda (f) (lambda (x) x))
(lambda (x) x)
#+END_SRC

Substituting:

#+BEGIN_SRC scheme
(lambda (f) (lambda (x) (f x)))
#+END_SRC

So one is:
#+BEGIN_SRC scheme
(define one (lambda (f) (lambda (x) (f x))))
#+END_SRC

Similarly if we evaluate ~(add-1 1)~, the number two will be:

#+BEGIN_SRC scheme
(define two (lambda (f) (lambda (x) (f (f x)))))
#+END_SRC

We can see that a number N is defined by a lambda expression in which a lambda function is applied N times to another lambda expression.

* Exercise 2.7
#+NAME: ex_2.7
#+BEGIN_SRC scheme
  (define (make-interval a b)
    (cons a b))

  (define (upper-bound interval)
    (cdr interval))

  (define (lower-bound interval)
    (car interval))

  (define (add-interval x y)
    (make-interval (+ (lower-bound x) (lower-bound y))
                   (+ (upper-bound x) (upper-bound y))))

  (define (mul-interval x y)
    (let ((p1 (* (lower-bound x) (lower-bound y)))
          (p2 (* (lower-bound x) (upper-bound y)))
          (p3 (* (upper-bound x) (lower-bound y)))
          (p4 (* (upper-bound x) (upper-bound y))))
      (make-interval (min p1 p2 p3 p4)
                     (max p1 p2 p3 p4))))

  (define (div-interval x y)
    (mul-interval x
                  (make-interval (/ 1.0 (upper-bound y))
                                 (/ 1.0 (lower-bound y)))))
#+END_SRC

#+RESULTS: ex_2.7
: #<unspecified>

* Exercise 2.8

#+BEGIN_SRC scheme :noweb yes :results output
  <<ex_2.7>>
  (define (sub-interval x y)
    (make-interval (- (lower-bound x) (upper-bound y))
                   (- (upper-bound x) (lower-bound y))))

  (display (sub-interval (make-interval 3 4)
                         (make-interval 0 2)))
#+END_SRC

#+RESULTS:
: (1 . 4)

* Exercise 2.9

In the case of addition and substraction, let's say we have two intervals: ~[x1, x2], [y1, y2]~

#+BEGIN_SRC
z = x + y = [x1+y1, x2+y2]
z2-z1 = x2-x1 + y2-y1 = width 1 + width 2

z = x - y = [x1-y2, x2-y1]
z2-z1 = x2-x1 + y2-y1 = width 1 + width 2
#+END_SRC

If it were a function of only the widths for multiplication and division, we would expect the resulting width to be the same for operations with same width input. We see that's not the case.

#+BEGIN_SRC scheme :noweb yes :results output
  <<ex_2.7>>

  (display "Mult\n")
  (display (mul-interval (make-interval 0 3)
                         (make-interval 2 7)))
  (display "\n")
  (display (mul-interval (make-interval 10 13)
                         (make-interval 0 5)))
  (display "\n")
  (display "Div\n")
  (display (div-interval (make-interval 1 3)
                         (make-interval 2 7)))
  (display "\n")
  (display (div-interval (make-interval 10 12)
                         (make-interval 1 6)))
#+END_SRC

#+RESULTS:
: Mult
: (0 . 21)
: (0 . 65)
: Div
: (0.14285714285714285 . 1.5)
: (1.6666666666666665 . 12.0)

* Exercise 2.10
#+BEGIN_SRC scheme :noweb yes :results output
  <<ex_2.7>>
  (define (div-interval x y)
    (if (< (* (lower-bound y) (upper-bound y)) 
           0)
        (error "Interval contains 0")
        (mul-interval x
                      (make-interval (/ 1.0 (upper-bound y))
                                     (/ 1.0 (lower-bound y))))))

  (display (div-interval (make-interval 10 12)
                         (make-interval 1 6)))
  (display "\n")
  (display (div-interval (make-interval 10 12)
                         (make-interval -2 6)))


#+END_SRC

#+RESULTS:
: ice-9/boot-9.scm:1669:16: In procedure raise-exception:
: Interval contains 0
: 
: Entering a new prompt.  Type `,bt' for a backtrace or `,q' to continue.
: scheme@(guile-user) [1]> 

* Exercise 2.11
We can construct a table with all the different possibilities. Here 0 means >= 0, 1 means < 0

| xl | xh | yl | yh |
|----+----+----+----|
|  0 |  0 |  0 |  0 |
|  0 |  0 |  0 |  1 |
|  0 |  0 |  1 |  0 |
|  0 |  0 |  1 |  1 |
|  0 |  1 |  0 |  0 |
|  0 |  1 |  0 |  1 |
|  0 |  1 |  1 |  0 |
|  0 |  1 |  1 |  1 |
|  1 |  0 |  0 |  0 |
|  1 |  0 |  0 |  1 |
|  1 |  0 |  1 |  0 |
|  1 |  0 |  1 |  1 |
|  1 |  1 |  0 |  0 |
|  1 |  1 |  0 |  1 |
|  1 |  1 |  1 |  0 |
|  1 |  1 |  1 |  1 |

But we have 16 cases, not 9 as Ben suggested. If we assume that the lower bound of an interval is less than the upper bound (which we have been doing so far), we can eliminate some of this cases, ending up with 9:

| xl | xh | yl | yh |
|----+----+----+----|
|  0 |  0 |  0 |  0 |
|  0 |  0 |  1 |  0 |
|  0 |  0 |  1 |  1 |
|  1 |  0 |  0 |  0 |
|  1 |  0 |  1 |  0 |
|  1 |  0 |  1 |  1 |
|  1 |  1 |  0 |  0 |
|  1 |  1 |  1 |  0 |
|  1 |  1 |  1 |  1 |

Having this, we can now each bound with only two multiplications (one for the lower bound, one for the upper bound), except for the case ~|  1 |  0 |  1 |  0 |~.

In this case need to test two different results for the lower bound, and the upper bound. Our final procedure is:

#+BEGIN_SRC scheme :noweb yes :results output
  <<ex_2.7>>
  (define (mul-interval x y)
    (let ((xl (lower-bound x))
          (xu (upper-bound x))
          (yl (lower-bound y))
          (yu (upper-bound y)))
      (cond ((and (>= xl 0)
                  (>= xu 0)
                  (>= yl 0)
                  (>= yu 0))
             (make-interval (* xl yl) (* xu yu)))
            ((and (>= xl 0)
                  (>= xu 0)
                  (< yl 0)
                  (>= yu 0))
             (make-interval (* xu yl) (* xu yu)))
            ((and (>= xl 0)
                  (>= xu 0)
                  (< yl 0)
                  (< yu 0))
             (make-interval (* xu yl) (* xl yu)))
            ((and (< xl 0)
                  (>= xu 0)
                  (>= yl 0)
                  (>= yu 0))
             (make-interval (* xl yl) (* xu yu)))
            ((and (< xl 0)
                  (>= xu 0)
                  (< yl 0)
                  (>= yu 0))
             (let ((l1 (* xl yu))
                   (l2 (* xu yl))
                   (u1 (* xl yl))
                   (u2 (* xu yu)))
               (make-interval (min l1 l2)
                              (max u1 u2))))
            ((and (< xl 0)
                  (>= xu 0)
                  (< yl 0)
                  (< yu 0))
             (make-interval (* xu yl) (* xl yu)))
            ((and (< xl 0)
                  (< xu 0)
                  (>= yl 0)
                  (>= yu 0))
             (make-interval (* xl yu) (* xu yl)))
            ((and (< xl 0)
                  (< xu 0)
                  (< yl 0)
                  (>= yu 0))
             (make-interval (* xl yu) (* xu yl)))
            ((and (< xl 0)
                  (< xu 0)
                  (< yl 0)
                  (< yu 0))
             (make-interval (* xu yu) (* xl yl))))))

  (display (mul-interval (make-interval -1 10)
                         (make-interval -2 3)))
#+END_SRC

#+RESULTS:
: (-20 . 30)

* Exercise 2.12
#+NAME: ex_2.12
#+BEGIN_SRC scheme :noweb yes
  <<ex_2.7>>
  (define (make-center-width c w)
    (make-interval (- c w) (+ c w)))

  (define (center i)
    (/ (+ (lower-bound i) (upper-bound i)) 2))

  (define (width i)
    (/ (- (upper-bound i) (lower-bound i)) 2))

  (define (make-center-percent c t)
    (make-interval (* c (- 1 (/ t 100)))
                   (* c (+ 1 (/ t 100)))))

  (define (percent i)
    (* (/ (width i) (center i)) 100))
#+END_SRC

* Exercise 2.17
#+BEGIN_SRC scheme
  (define (last-pair list)
    (if (null? (cdr list))
        (car list)
        (last-pair (cdr list))))

  (last-pair (list 23 72 149 34))
#+END_SRC

#+RESULTS:
: 34

* Exercise 2.18

#+BEGIN_SRC scheme 
    (define (reverse items)
      (if (null? items)
          items
          (append (reverse (cdr items)) 
                  (list (car items)))))

  (reverse (list 1 4 9 16 25))
#+END_SRC

#+RESULTS:
| 25 | 16 | 9 | 4 | 1 |

* Exercise 2.19
#+BEGIN_SRC scheme

  (define (except-first-denomination coin-values)
    (cdr coin-values))

  (define (first-denomination coin-values)
    (car coin-values))

  (define (no-more? coin-values)
    (null? coin-values))

  (define (cc amount coin-values)
    (cond ((= amount 0) 1)
          ((or (< amount 0) (no-more? coin-values)) 0)
          (else
           (+ (cc amount
                  (except-first-denomination coin-values))
              (cc (- amount
                     (first-denomination coin-values))
                  coin-values)))))


  (define us-coins (list 50 25 10 5 1))
  (define us-coins-r (list 1 5 10 25 50))

  (define uk-coins (list 100 50 20 10 5 2 1 0.5))



 (cc 100 us-coins)

#+END_SRC

#+RESULTS:
: 292

* Exercise 2.20
Dotted-tail notation. Arbitrary number  of arguments
#+BEGIN_SRC scheme
  (define (same-parity . input)
    (define (same-parity-helper parity result input)
      (cond ((null? input)
             result)
            ((= (remainder (car input) 2) parity)
             (same-parity-helper parity
                                 (append result (list (car input)))
                                 (cdr input)))
            ((same-parity-helper parity
                                 result
                                 (cdr input)))))

    (same-parity-helper (remainder (car input) 2)
                        (list (car input))
                        (cdr input)))
  (same-parity 2 3 4 5 6 7 10)
#+END_SRC

#+RESULTS:
| 2 | 4 | 6 | 10 |

* Exercise 2.21

Without map:
#+BEGIN_SRC scheme
  (define (square-list items)
    (if (null? items)
        '()
        (cons (* (car items) (car items))
              (square-list (cdr items)))))
  (square-list (list 1 2 3 4))
#+END_SRC

#+RESULTS:
| 1 | 4 | 9 | 16 |

With map:
#+BEGIN_SRC scheme
  (define (square-list items)
    (map (lambda (x) (* x x))
         items))
  (square-list (list 1 2 3 4))
#+END_SRC

#+RESULTS:
| 1 | 4 | 9 | 16 |

* Exercise 2.22

The first implementation produces the answer in the reversed order becasue we keep are adding the square car of the list and adding it to the answer, and then iterating over the cdr of the list.

#+BEGIN_SRC scheme
  (define (square x)
    (* x x))
  (define (square-list items)
    (define (iter things answer)
      (if (null? things)
          answer
          (iter (cdr things)
                (cons answer
                      (square (car things))))))
    (iter items '()))
    (square-list (list 1 2 3 4))
#+END_SRC

This will produce:
((((() . 1) . 4) . 9) . 16)

The reason is that now with cons we are not construction a correct list.
In the first iteration we create a pair ('() . 1). Then we make this the first element of the next pair, (('() . 1) . 4), and so on.
This construction has the form:

(cons (cons (cons nil 1) 4) 9)...

When a correct list has the form (abbreviated to 9 elements):
(cons 1 (cons 4 (cons 9 nil))) 

* Exercise 2.23

#+BEGIN_SRC scheme :results output
  (define (for-each proc items)
    (cond ((null? items)
           #t)
          ((proc (car items))
           (for-each proc (cdr items)))))

  (for-each (lambda (x) (display "\n") (display x))
            (list 57 321 88))
#+END_SRC

#+RESULTS:
: 
: 57
: 321
: 88

* Exercise 2.24
Result:
#+BEGIN_SRC 
(1 (2 (3 4)))
#+END_SRC

Box pointer structure
#+BEGIN_SRC 
(1 (2 (3 4))
             +---+---+                  +---+---+     +---+---+
        ---->| * | *-+----------------->| * | *-+---->| * | / |
             +---+---+                  +---+---+     +---+---=
               |                          |             |
               V                          V             V
             +---+                      +---+   (3 4) +---+---+    +---+---+
             | 1 |                      | 2 |     --->| * | *-+--->| * | / |
             +---+                      +---+         +---+---+    +---+---+
                                                        |            |
                                                        V            V
                                                      +---+        +---+
                                                      | 3 |        | 4 |
                                                      +---+        +---+
#+END_SRC

Tree structure
#+BEGIN_SRC 
            (1 (2 (3 4)))
                /\
               /  \
              1  (2 (3 4))
                   /\
                  /  \
                 2  (3 4)
                     /\
                    3  4
#+END_SRC

* Exercise 2.25
#+BEGIN_SRC scheme
(define list1 (list 1 3 (list 5 7) 9))
(car (cdr (car (cdr (cdr list1)))))

(define list2 (list (list 7)))
(car (car list2))

(define list3 (list 1 (list 2 (list 3 (list 4 (list 5 (list 6 7)))))))
(car (cdr (car (cdr (car (cdr (car (cdr (car (cdr (car (cdr list3))))))))))))
#+END_SRC

* Exercise 2.26

#+BEGIN_SRC 
(append x y)
(1 2 3 4 5 6)
#+END_SRC

#+BEGIN_SRC 
(cons x y)
((1 2 3) 4 5 6)
#+END_SRC

#+BEGIN_SRC 
(list x y)
((1 2 3) (4 5 6))
#+END_SRC

* Exercise 2.27

~deep-reverse~ is similar to ~reverse~, from exercise 2.18. The only difference is that if one of the branches is a tree (this is, a pair), we recursively apply it to those elements as well, to reverse them within the subtree.

#+BEGIN_SRC scheme 
  (define (deep-reverse items)
    (cond ((null? items)
           items)
          ((pair? (car items))
           (append (deep-reverse (cdr items)) 
                   (list (deep-reverse (car items)))))
          ((append (deep-reverse (cdr items)) 
                   (list (car items))))))

  (define x (list (list 1 2) (list 3 4) 5 6 ))
  (deep-reverse x)
#+END_SRC

#+RESULTS:
| 6 | 5 | (4 3) | (2 1) |

* Exercise 2.28

#+NAME: fringe
#+BEGIN_SRC scheme
  (define (fringe items)
    (cond ((null? items)
           items)
          ((not (pair? items))
           (list items))
          ((append (fringe (car items))
                   (fringe (cdr items))))))


  (define x (list (list 1 2) (list 3 4)))

  (fringe x)
#+END_SRC
#+RESULTS:
| 1 | 2 | 3 | 4 |

* Exercise 2.29

#+NAME: mobile_basics
#+BEGIN_SRC scheme
  (define (make-mobile left right)
    (list left right))
  (define (make-branch length structure)
    (list length structure))

  (define (left-branch mobile)
    (list-ref mobile 0))
  (define (right-branch mobile)
    (list-ref mobile 1))
  (define (branch-length branch)
    (list-ref branch 0))
  (define (branch-structure branch)
    (list-ref branch 1))

  (define (total-weight mobile)
    (if (not (pair? mobile))
        mobile
        (+ (total-weight (branch-structure (left-branch mobile)))
           (total-weight (branch-structure (right-branch mobile))))))



  (define my-mobile (make-mobile (make-branch 2 3)
                                 (make-branch 1 (make-mobile (make-branch 1 2)
                                                             (make-branch 3 5)))))
  (total-weight my-mobile)

#+END_SRC

#+RESULTS:
: 10

#+BEGIN_SRC scheme :noweb yes :results output
  <<mobile_basics>>

  (define (is-balanced? mobile)  
    (if (not (pair? mobile))
        #t
        (let ((mobile-right-branch (right-branch mobile))
              (mobile-left-branch (left-branch mobile)))
          (and (= (* (total-weight (branch-structure mobile-left-branch))
                     (branch-length mobile-left-branch))
                  (* (total-weight (branch-structure mobile-right-branch))
                     (branch-length mobile-right-branch)))
               (is-balanced? (branch-structure mobile-left-branch))
               (is-balanced? (branch-structure mobile-right-branch))))))

  (define my-mobile (make-mobile (make-branch 2 3)
                                 (make-branch 1 (make-mobile (make-branch 1 2)
                                                             (make-branch 3 5)))))
  (display (is-balanced? my-mobile))

  (define my-mobile-balanced (make-mobile (make-branch 2 3)
                                          (make-branch 1 (make-mobile (make-branch 1 2)
                                                                      (make-branch 0.5 4)))))
  (display "\n")
  (display (is-balanced? my-mobile-balanced))
#+END_SRC

#+RESULTS:
: #f
: #t

If we changed the constructors from ~list~ to ~cons~, we'd need to change the accesors and the pair? check at the programs. Maybe create a ~is-weight?~ procedure so we don't depend on the internal representation of the mobile.

* Exercise 2.30
Direct implementation:
#+BEGIN_SRC scheme
  (define (square-tree tree)
    (cond ((null? tree) '())
          ((not (pair? tree)) (* tree tree))
          (else (cons (square-tree (car tree))
                      (square-tree (cdr tree))))))

  (square-tree
   (list 1
         (list 2 (list 3 4) 5)
         (list 6 7)))
#+END_SRC

#+RESULTS:
| 1 | (4 (9 16) 25) | (36 49) |

Map implementation:
#+BEGIN_SRC scheme
  (define (square-tree tree)
    (map (lambda (sub-tree)
           (if (not (pair? sub-tree))
               (* sub-tree sub-tree)
               (square-tree sub-tree)))
         tree))
  (square-tree
   (list 1
         (list 2 (list 3 4) 5)
         (list 6 7)))

#+END_SRC

#+RESULTS:
| 1 | (4 (9 16) 25) | (36 49) |

* Exercise 2.31
#+BEGIN_SRC scheme
  (define (square x)
    (* x x))
  
(define (tree-map proc tree)
    (map (lambda (sub-tree)
           (if (not (pair? sub-tree))
               (proc sub-tree)
               (tree-map proc sub-tree)))
         tree))


  (define (square-tree tree) (tree-map square tree))
  (square-tree
   (list 1
         (list 2 (list 3 4) 5)
         (list 6 7)))
#+END_SRC

#+RESULTS:
| 1 | (4 (9 16) 25) | (36 49) |

* Exercise 2.32

We start by specifying that the subsets of an empty set, is the empty set: ~(())~

Then, the other insight is that the subsets can be obtained by:
- Getting the subsets of the set minus one element (~let ((rest (substes (cdr s))))...~)
- And adding the element to every subset we obtained (also including the subsets without the element)

For example, let's say que have ~(1 2 3)~

If we find the subsets of ~(2 3)~ we have: ~(() (2) (3) (2 3))~
Now if we add 1 to those subsets ~((1) (1 2) (1 3) (1 2 3))~
Putting all together ~(() (2) (3) (2 3) (1) (1 2) (1 3) (1 2 3))~

#+BEGIN_SRC scheme
  (define (subsets s)
    (if (null? s)
        (list '())
        (let ((rest (subsets (cdr s))))
          (append rest
                  (map
                   (lambda (l) (cons (car s) l))
                   rest)))))

  (subsets (list 1 2 3))
#+END_SRC

#+RESULTS:
|---+---+---|
| 3 |   |   |
| 2 |   |   |
| 2 | 3 |   |
| 1 |   |   |
| 1 | 3 |   |
| 1 | 2 |   |
| 1 | 2 | 3 |

* Exercise 2.33
#+NAME: sequence_procs
#+BEGIN_SRC scheme
  (define (accumulate op initial sequence)
    (if (null? sequence)
        initial
        (op (car sequence)
            (accumulate op initial (cdr sequence)))))

  (define (filter predicate sequence)
    (cond ((null? sequence) '())
          ((predicate (car sequence))
           (cons (car sequence)
                 (filter predicate (cdr sequence))))
          (else (filter predicate (cdr sequence)))))
  (define (enumerate-interval low high)
    (if (> low high)
        '()
        (cons low (enumerate-interval (+ low 1) high))))
#+END_SRC

#+BEGIN_SRC scheme :noweb yes :results output
  <<sequence_procs>>

  (define (map p sequence)
    (accumulate (lambda (x y) (cons (p x) y)) '() sequence))

  (define (append seq1 seq2)
    (accumulate cons seq2 seq1))

  (define (length sequence)
    (accumulate (lambda (x y) (+ y 1)) 0 sequence))

  (display (map (lambda (x) (+ 2 x)) (list 1 2 3)))
  (display "\n")
  (display (append (list 1 2 3) (list 4 5 6)))
  (display "\n")
  (display (length (list 1 2 3 4 5)))

#+END_SRC

#+RESULTS:
: (3 4 5)
: (1 2 3 4 5 6)
: 5

* Exercise 2.34
Evaluate polynomial with Horner's rule:

#+BEGIN_SRC scheme :noweb yes
  <<sequence_procs>>

  (define (horner-eval x coefficient-sequence)
    (accumulate (lambda (this-coeff higher-terms)
                  (+ this-coeff
                     (* x higher-terms)))
                0
                coefficient-sequence))

  ;; 1 + 3x + 5x^3 + x^5 at x = 2
  (horner-eval 2 (list 1 3 0 5 0 1))
#+END_SRC

#+RESULTS:
: 79

* Exercise 2.35

With ~fringe~ (~enumerate-tree~) it's easy to do. Not sure how ~map~ (hint) helps here.

#+BEGIN_SRC scheme :noweb yes
  <<fringe>>
  <<sequence_procs>>
  (define (count-leaves t)
    (accumulate (lambda (x y) (+ 1 y)) 0 (fringe t)))

  (define x (list (list 1 2) (list 3 4)))
  (count-leaves x)
#+END_SRC

#+RESULTS:
: 4

* Exercise 2.36

#+NAME: accumulate-n
#+BEGIN_SRC scheme :noweb yes
  <<sequence_procs>>
  (define (accumulate-n op init seqs)
    (if (null? (car seqs))
        '()
        (cons (accumulate op init (map (lambda (x) (car x))
                                       seqs))
              (accumulate-n op init (map (lambda (x) (cdr x))
                                         seqs)))))


  (define s (list (list 1 2 3) (list 4 5 6) (list 7 8 9) (list 10 11 12)))

  (accumulate-n + 0 s)
#+END_SRC

#+RESULTS:
| 22 | 26 | 30 |

* Exercise 2.37

#+BEGIN_SRC scheme :noweb yes :results output
  <<sequence_procs>>
  <<accumulate-n>>

  (define (dot-product v w)
    (accumulate + 0 (map * v w)))

  (define (matrix-*-vector m v)
    (map (lambda (mvec) (dot-product mvec v))  m))

  (define (transpose mat)
    (accumulate-n cons '() mat))

  (define (matrix-*-matrix m n)
    (let ((cols (transpose n)))
      (map (lambda (mvec) (matrix-*-vector cols mvec)) m)))

  (define m (list (list 1 2 3 4) (list 4 5 6 6) (list 6 7 8 9)))
  (define square-m (list (list 1 2 3) (list 4 5 6) (list 7 8 9)))
  (define v (list 7 5 3 1))

  (display "matrix * vector\n")
  (display (matrix-*-vector m v))
  (display "\ntranspose\n")
  (display (transpose m))
  (display "\nmatrix*matrix\n")
  (display (matrix-*-matrix square-m square-m))
#+END_SRC

#+RESULTS:
: matrix * vector
: (30 77 110)
: transpose
: ((1 4 6) (2 5 7) (3 6 8) (4 6 9))
: matrix*matrix
: ((30 36 42) (66 81 96) (102 126 150))

* Exercise 2.38

#+NAME: fold-left
#+BEGIN_SRC scheme :noweb yes :results output
  <<sequence_procs>>

  (define (fold-left op initial sequence)
    (define (iter result rest)
      (if (null? rest)
          result
          (iter (op result (car rest))
                (cdr rest))))
    (iter initial sequence))

  (display (accumulate / 1 (list 1 2 3)))
  (display "\n")
  (display (fold-left / 1 (list 1 2 3)))
  (display "\n")
  (display (accumulate list '() (list 1 2 3)))
  (display "\n")
  (display (fold-left list '() (list 1 2 3)))
  (display "\n")
  (display (accumulate + 3 (list 1 2 3)))
  (display "\n")
  (display (fold-left + 3 (list 1 2 3)))
  (display "\n")
  (display (accumulate * 0.5 (list 1 2 3)))
  (display "\n")
  (display (fold-left * 0.5 (list 1 2 3)))
  (display "\n")
#+END_SRC

#+RESULTS: fold-left
: 3/2
: 1/6
: (1 (2 (3 ())))
: (((() 1) 2) 3)
: 9
: 9
: 3.0
: 3.0

#+BEGIN_SRC
(fold-right / 1 (list 1 2 3))
(/ 1 (fold-right / 1 (list 2 3))
(/ 1 (/ 2 (fold-right / 1 (list 3))))
(/ 1 (/ 2 (/ 3 (accumulate / 1 '()))))
(/ 1 (/ 2 (/ 3 1)))
;; 1 / (2 / (3 /1))
;; 1 op (2 op (3 op initial))

(fold-left / 1 (list 1 2 3))
(iter 1 (list 1 2 3))
(iter (/ 1 1) (list 2 3))
(iter (/ (/ 1 1) 2) (list 3))
(iter (/ (/ (/1 1) 2) 3) '())
(/ (/ (/1 1) 2) 3)
;; ((1/1) / 2) /3
;; ((1 op initial) op 2) op 3
#+END_SRC

We need 2 properties:
- Commutativity, because the initial value can be applied to the first or last element of the list
- Associativity, because the order in which we perform the operations changes between fold-left and fold-right

An example of an ~op~ that would satisfy this is ~+~

* Exercise 2.39

First, trying to understand that flatmap and lambda func:

#+BEGIN_SRC scheme :noweb yes
  <<sequence_procs>>
  (define (enumerate-interval low high)
    (if (> low high)
        '()
        (cons low (enumerate-interval (+ low 1) high))))


  (accumulate append
              '()
              (map (lambda (i)
                     (map (lambda (j) (list i j))
                          (enumerate-interval 1 (- i 1))))
                   (enumerate-interval 1 10)))

  (enumerate-interval 1 10)

  (map (lambda (i)
         (map (lambda (j) (list i j))
              (enumerate-interval 1 (- i 1))))
       (enumerate-interval 1 10))
#+END_SRC

#+RESULTS:
|--------+--------+--------+--------+--------+--------+--------+--------+--------|
| (2 1)  |        |        |        |        |        |        |        |        |
| (3 1)  | (3 2)  |        |        |        |        |        |        |        |
| (4 1)  | (4 2)  | (4 3)  |        |        |        |        |        |        |
| (5 1)  | (5 2)  | (5 3)  | (5 4)  |        |        |        |        |        |
| (6 1)  | (6 2)  | (6 3)  | (6 4)  | (6 5)  |        |        |        |        |
| (7 1)  | (7 2)  | (7 3)  | (7 4)  | (7 5)  | (7 6)  |        |        |        |
| (8 1)  | (8 2)  | (8 3)  | (8 4)  | (8 5)  | (8 6)  | (8 7)  |        |        |
| (9 1)  | (9 2)  | (9 3)  | (9 4)  | (9 5)  | (9 6)  | (9 7)  | (9 8)  |        |
| (10 1) | (10 2) | (10 3) | (10 4) | (10 5) | (10 6) | (10 7) | (10 8) | (10 9) |


Let's try the permutation example
#+NAME: permutation
#+BEGIN_SRC scheme :noweb yes
  <<sequence_procs>>
  (define (flatmap proc seq)
    (accumulate append '() (map proc seq)))

  (define (remove element seq)
    (filter (lambda (x) (not (= x element)))
            seq))

  (define (permutations s)
    (if (null? s)                    ; empty set?
        (list '())                   ; sequence containing empty set
        (flatmap (lambda (x)
                   (map (lambda (p) (cons x p))
                        (permutations (remove x s))))
                 s)))
  (permutations '(3 1 2))
#+END_SRC

#+RESULTS: permutation
| 3 | 1 | 2 |
| 3 | 2 | 1 |
| 1 | 3 | 2 |
| 1 | 2 | 3 |
| 2 | 3 | 1 |
| 2 | 1 | 3 |

* Exercise 2.40

#+NAME: unique-pairs
#+BEGIN_SRC scheme :noweb yes
  <<sequence_procs>> ;; for enumerate-interval
  <<permutation>>  ;; for flatmap
  (define (unique-pairs n)
    (flatmap (lambda (j)
               (map (lambda (i) (list j i))
                    (enumerate-interval 1 (- j  1))))
             (enumerate-interval 1 n)))

  (unique-pairs 4)
#+END_SRC

We have ~(n choose 2)~ possible pairs
#+RESULTS: unique-pairs
| 2 | 1 |
| 3 | 1 |
| 3 | 2 |
| 4 | 1 |
| 4 | 2 |
| 4 | 3 |

* Exercise 2.41

#+BEGIN_SRC scheme :noweb yes
  <<sequence_procs>>
  <<permutation>>

  (define (unique-triples n)
    (flatmap (lambda (i)
               (flatmap (lambda (j)
                          (map (lambda (k) (list i j k))
                               (enumerate-interval 1 (- j 1))))
                (enumerate-interval 1 (- i 1))))
    (enumerate-interval 1 n)))

  (define (make-triple-sum triple)
    (list (car triple) (cadr triple) (caddr triple) (+ (car triple) (cadr triple) (caddr triple))))

  (define (sum-to-s triple s)
    (= (+ (car triple) (cadr triple) (caddr triple)) s))

  (define (triple-sum-to-s n s)
    (map make-triple-sum
         (filter (lambda (x) (sum-to-s x s))
                 (unique-triples n))))

  (triple-sum-to-s 7 12)
#+END_SRC

#+RESULTS:
| 5 | 4 | 3 | 12 |
| 6 | 4 | 2 | 12 |
| 6 | 5 | 1 | 12 |
| 7 | 3 | 2 | 12 |
| 7 | 4 | 1 | 12 |

* Exercise 2.42

Interesting! I remember solving on this problem on assembler back in my college days.

#+NAME: queens
#+BEGIN_SRC scheme :noweb yes
  <<sequence_procs>>
  <<permutation>>

  ;; Ended up spending 2 hours debugging my program because I was creating a list with an empty list:
  ;; (list '())
  ;; So far this is the biggest drawback I see to Lisp. Backtrace is very unhelpful
  (define empty-board '() )

  (define (adjoin-position row column rest)
    (cons (list row column) rest))

  (define (get-row queen)
    (car queen))

  (define (get-column queen)
    (cadr queen))

  (define (same-column? first_queen second_queen)
    (= (get-column first_queen) (get-column second_queen)))

  (define (same-row? first_queen second_queen)
    (= (get-row first_queen) (get-row second_queen)))

  (define (same-diagonal? first_queen second_queen)
    (or (= (+ (get-row first_queen) (get-column first_queen))
           (+ (get-row second_queen) (get-column second_queen)))
        (= (- (get-row first_queen) (get-column first_queen))
           (- (get-row second_queen) (get-column second_queen)))))


  (define (safe? column queens)
    ;; I probably can extract these 2 into methods...
    (let ((queen (car (filter (lambda (queen) (= (get-column queen) column)) queens)))
          (rest (filter (lambda (queen) (not (= (get-column queen) column))) queens)))
      (cond ((null? rest) #t)
            ;; Check if all the checks are False by using accumulate
            (else (not (accumulate (lambda (x y) (or x y)) #f 
                             (map (lambda (comp-queen) (or (same-column? queen comp-queen)
                                                           (same-row? queen comp-queen)
                                                           (same-diagonal? queen comp-queen)))
                                  rest)))))))

  (define (queens board-size)
    (define (queen-cols k)
      (if (= k 0)
          (list empty-board)
          (filter
           (lambda (positions) (safe? k positions))
           (flatmap
            (lambda (rest-of-queens)
              (map (lambda (new-row)
                     (adjoin-position new-row k rest-of-queens))
                   (enumerate-interval 1 board-size)))
            (queen-cols (- k 1))))))
    (queen-cols board-size))

  (queens 6)
#+END_SRC

#+RESULTS: queens
| (5 6) | (3 5) | (1 4) | (6 3) | (4 2) | (2 1) |
| (4 6) | (1 5) | (5 4) | (2 3) | (6 2) | (3 1) |
| (3 6) | (6 5) | (2 4) | (5 3) | (1 2) | (4 1) |
| (2 6) | (4 5) | (6 4) | (1 3) | (3 2) | (5 1) |

Result:
| (5 6) | (3 5) | (1 4) | (6 3) | (4 2) | (2 1) |
| (4 6) | (1 5) | (5 4) | (2 3) | (6 2) | (3 1) |
| (3 6) | (6 5) | (2 4) | (5 3) | (1 2) | (4 1) |
| (2 6) | (4 5) | (6 4) | (1 3) | (3 2) | (5 1) |

* Exercise 2.43
These are my current thoughts of this:
In the original proc we call flat map every time over a board 1 square smaller than the previous iteration. Being the size of the board n:

#+BEGIN_SRC
O(n*(n-1)*(n-2)...) = O(n!)
#+END_SRC


In the new proc, que call it over every flatmap iteration. If we had a board of size 2 we would have:

#+BEGIN_SRC
O(f(1)) = 1
O(f(2)) = 2*(2*O(1)) = O(2*(2*1))=O(2^2)
#+END_SRC

Size 3:

#+BEGIN_SRC
O(3*(3*(2*(2*1)))) = O(3^3*2^2) ~ O(3^3)
#+END_SRC

Finally, for a board of size n:

#+BEGIN_SRC
O(n*(n*((n-1)*(n-1)...) = O(n^n*(n-1)^(n-1)...)~ O(n^n)
#+END_SRC

* Exercise 2.44

#+BEGIN_SRC scheme
  (define (up-split painter n)
    (if (= n 0)
        painter
        (let ((smaller (up-split painter (- n 1))))
          (below painter (beside smaller smaller)))))
#+END_SRC

* Exercise 2.45
#+BEGIN_SRC scheme
  (define (split painter-pos smaller-pos)
    (lambda (painter n)
          (if (= n 0)
          painter
          (let ((smaller (split painter (- n 1))))
            (painter-pos painter (smaller-pos smaller smaller))))))

  (define right-split (split beside below))
  (define up-split (split below beside))
#+END_SRC

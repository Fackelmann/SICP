#+PROPERTY: header-args    :exports both
This is an org-mode file with ~scheme~ code blocks. If you clone this repo you can execute each block inside this file with ~C-c C-c~.

Because of some mysterious reason, results don't show up in the rendered github file. You can see them by opening the raw file.

* Table of Contents :TOC:
- [[#common][Common]]
- [[#exercise-21][Exercise 2.1]]
- [[#exercise-22][Exercise 2.2]]
- [[#exercise-23][Exercise 2.3]]
- [[#exercise-24][Exercise 2.4]]
- [[#exercise-25][Exercise 2.5]]
- [[#exercise-26][Exercise 2.6]]
- [[#exercise-27][Exercise 2.7]]
- [[#exercise-28][Exercise 2.8]]
- [[#exercise-29][Exercise 2.9]]

* Common

Defining commong functions here, so we don't need to repeat them over all the code blocks. 
#+NAME: common_block
#+BEGIN_SRC scheme
  (define (square x)
    (* x x))

  (define (gcd a b)
    (if (= b 0)
        a
        (gcd b (remainder a b))))

  (define (power x n)
    (if (= n 0)
        1
        (* x (power x (- n 1)))))
#+END_SRC


* Exercise 2.1
#+BEGIN_SRC scheme :noweb yes :results output
  <<common_block>>
  (define (numer x) (car x))

  (define (denom x) (cdr x))

  (define (print-rat x)
    (display "\n")
    (display (numer x))
    (display "/")
    (display (denom x)))

  (define (make-rat n d)
    (define (is-positive? n d)
      (cond ((and (> n 0) (< d 0))
             -1)
            ((and (< n 0) (> d 0))
             -1)
            (else
             1)))
    (let ((g (gcd n d))
          (sign (is-positive? n d)))
      (cons (* sign (/ n g)) (* sign (/ d g)))))

  (print-rat (make-rat 3 -6))
  (print-rat (make-rat -3 6))
  (print-rat (make-rat -3 -6))
  (print-rat (make-rat 3 6))

#+END_SRC

#+RESULTS:
: 
: -1/2
: -1/2
: 1/2
: 1/2

* Exercise 2.2

#+NAME: ex_2.2
#+BEGIN_SRC scheme :results output
  (define (make-segment start end)
    (cons start end))

  (define (start-segment segment)
    (car segment))

  (define (end-segment segment)
    (cdr segment))

  (define (make-point x y)
    (cons x y))

  (define (x-point point)
    (car point))

  (define (y-point point)
    (cdr point))

  (define (print-point p)
    (display "\n")
    (display "(")
    (display (x-point p))
    (display ",")
    (display (y-point p))
    (display ")"))

  (define (midpoint-segment segment)
    (let ((start (start-segment segment))
          (end (end-segment segment)))
      (let ((midx (/ (+ (x-point start)
                        (x-point end))
                     2))
            (midy (/ (+ (y-point start)
                        (y-point end))
                     2)))
        (make-point midx midy))))

  (define my-segment (make-segment (make-point 1 1)
                                   (make-point 2 2)))

  (define midpoint (midpoint-segment my-segment))

;;  (print-point midpoint)
#+END_SRC

#+RESULTS:
: 
: (3/2,3/2)

* Exercise 2.3

#+BEGIN_SRC scheme :noweb yes :results output
  <<ex_2.2>>
  ;; Implement rectangles with sides parallel to the axis for now
  ;; Generalizing it adds complexity without addin much value (IMO) to this exercise
  (define (rectangle lower_left upper_right)
    (cons lower_left upper_right))

  (define (rect-ll rectangle)
    (car rectangle))

  (define (rect-ur rectangle)
    (cdr rectangle))

  (define (rect-perimeter rectangle)
    (* (+ (- (x-point (rect-ur rectangle))
             (x-point (rect-ll rectangle)))
          (- (y-point (rect-ur rectangle))
             (y-point (rect-ll rectangle))))
       2))

  (define (rect-area rectangle)
    (* (- (x-point (rect-ur rectangle))
          (x-point (rect-ll rectangle)))
       (- (y-point (rect-ur rectangle))
          (y-point (rect-ll rectangle)))))

  (define my-rectangle (rectangle (make-point 1 0)
                                  (make-point 10 2)))

  (display "\n")
  (display (rect-perimeter my-rectangle))
  (display "\n")
  (display (rect-area my-rectangle))
#+END_SRC

#+RESULTS:
: 
: 22
: 18

* Exercise 2.4
Check that it works as expected:
#+BEGIN_SRC scheme
(car (cons 3 2))
(car (lambda (m) (m 3 2)))
((lambda (p q) p) 3 2)
3
#+END_SRC

And ~cdr~ implementation:
#+BEGIN_SRC scheme
  (define (cdr z)
    (z (lambda (p q) q)))
#+END_SRC

* Exercise 2.5

#+BEGIN_SRC scheme :noweb yes :results output
  <<common_block>>
  (define (cons a b)
    (* (power 2 a)
       (power 3 b)))

  (define (max-exponent n a)
    (if (= 0 (remainder n a))
        (+ 1 (max-exponent (/ n a)  a))
        0))

  (define (car z)
    (max-exponent z 2))

  (define (cdr z)
    (max-exponent z 3))

  ;; Test
  ;; It seems that Guile doesn't suppor assert
  ;; strange
  ;; (let ((list (cons 5 7)))
  ;;   (assert (= (car list) 5))
  ;;   (assert (= (cdr list) 7)))

  ;; Test

  (let ((list (cons 5 7)))
    (display "\n")
    (display (= (car list) 5))
    (display "\n")
    (display (= (cdr list) 7)))

  (let ((list (cons 127 1)))
    (display "\n")
    (display (= (car list) 127))
    (display "\n")
    (display (= (cdr list) 1)))

  (let ((list (cons 21 32)))
    (display "\n")
    (display (= (car list) 21))
    (display "\n")
    (display (= (cdr list) 32)))
#+END_SRC

#+RESULTS:
: 
: #t
: #t
: #t
: #t
: #t
: #t

* Exercise 2.6

Let's start by evaluating ~(add-1 zero)~
#+BEGIN_SRC scheme
(add-1 zero)
(lambda (f) (lambda (x) (f ((zero f) x))))
#+END_SRC

And evaluating ~(zero f)~

#+BEGIN_SRC scheme
(zero f)
(lambda (f) (lambda (x) x))
(lambda (x) x)
#+END_SRC

Substituting:

#+BEGIN_SRC scheme
(lambda (f) (lambda (x) (f x)))
#+END_SRC

So one is:
#+BEGIN_SRC scheme
(define one (lambda (f) (lambda (x) (f x))))
#+END_SRC

Similarly if we evaluate ~(add-1 1)~, the number two will be:

#+BEGIN_SRC scheme
(define two (lambda (f) (lambda (x) (f (f x)))))
#+END_SRC

We can see that a number N is defined by a lambda expression in which a lambda function is applied N times to another lambda expression.

* Exercise 2.7
#+NAME: ex_2.7
#+BEGIN_SRC scheme
  (define (make-interval a b)
    (cons a b))

  (define (upper-bound interval)
    (cdr interval))

  (define (lower-bound interval)
    (car interval))

  (define (add-interval x y)
    (make-interval (+ (lower-bound x) (lower-bound y))
                   (+ (upper-bound x) (upper-bound y))))

  (define (mul-interval x y)
    (let ((p1 (* (lower-bound x) (lower-bound y)))
          (p2 (* (lower-bound x) (upper-bound y)))
          (p3 (* (upper-bound x) (lower-bound y)))
          (p4 (* (upper-bound x) (upper-bound y))))
      (make-interval (min p1 p2 p3 p4)
                     (max p1 p2 p3 p4))))

  (define (div-interval x y)
    (mul-interval x
                  (make-interval (/ 1.0 (upper-bound y))
                                 (/ 1.0 (lower-bound y)))))
#+END_SRC

#+RESULTS: ex_2.7
: #<unspecified>

* Exercise 2.8

#+BEGIN_SRC scheme :noweb yes :results output
  <<ex_2.7>>
  (define (sub-interval x y)
    (make-interval (- (lower-bound x) (upper-bound y))
                   (- (upper-bound x) (lower-bound y))))

  (display (sub-interval (make-interval 3 4)
                         (make-interval 0 2)))
#+END_SRC

#+RESULTS:
: (1 . 4)

* Exercise 2.9

In the case of addition and substraction, let's say we have two intervals: ~[x1, x2], [y1, y2]~

#+BEGIN_SRC
z = x + y = [x1+y1, x2+y2]
z2-z1 = x2-x1 + y2-y1 = width 1 + width 2

z = x - y = [x1-y2, x2-y1]
z2-z1 = x2-x1 + y2-y1 = width 1 + width 2
#+END_SRC

If it were a function of only the widths for multiplication and division, we would expect the resulting width to be the same for operations with same width input. We see that's not the case.

#+BEGIN_SRC scheme :noweb yes :results output
  <<ex_2.7>>

  (display "Mult\n")
  (display (mul-interval (make-interval 0 3)
                         (make-interval 2 7)))
  (display "\n")
  (display (mul-interval (make-interval 10 13)
                         (make-interval 0 5)))
  (display "\n")
  (display "Div\n")
  (display (div-interval (make-interval 1 3)
                         (make-interval 2 7)))
  (display "\n")
  (display (div-interval (make-interval 10 12)
                         (make-interval 1 6)))
#+END_SRC

#+RESULTS:
: Mult
: (0 . 21)
: (0 . 65)
: Div
: (0.14285714285714285 . 1.5)
: (1.6666666666666665 . 12.0)
